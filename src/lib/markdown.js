export const events_compiledmap={
  "CP29_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_10(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"Lock in, stay sharp, and think two steps ahead. Welcome to VALORANT, where razor-precise gunplay collides with high-IQ strategy. Pick an agent that matches your style, bend the round with game-changing abilities, and coordinate with your squad to outsmart\\u2014not just outshoot\\u2014the opposition. Every round is a mind game, every clutch a statement. One mistake costs the round. One smart play wins the match.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Tournament Format\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rules & Conduct\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#format\",\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h1;\n  let t1;\n  let centersection;\n  let t2;\n  let h2;\n  let t4;\n  let p0;\n  let t8;\n  let p1;\n  let t12;\n  let p2;\n  let t16;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"VALORANT\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h2 = element(\"h2\");\n      h2.textContent = \"Event Details\";\n      t4 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Registration Fee:</strong> <strong>\\u20B949</strong>`;\n      t8 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Total Prize Pool:</strong> <strong>Rs. 3,500</strong>`;\n      t12 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Team Size:</strong> <strong>5 - 6 Members</strong>`;\n      t16 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h2, anchor);\n      insert(target, t4, anchor);\n      insert(target, p0, anchor);\n      insert(target, t8, anchor);\n      insert(target, p1, anchor);\n      insert(target, t12, anchor);\n      insert(target, p2, anchor);\n      insert(target, t16, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(t2);\n        detach(h2);\n        detach(t4);\n        detach(p0);\n        detach(t8);\n        detach(p1);\n        detach(t12);\n        detach(p2);\n        detach(t16);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h30;\n  let t1;\n  let p0;\n  let t3;\n  let ul0;\n  let t15;\n  let h31;\n  let t17;\n  let p1;\n  let t19;\n  let ul1;\n  let t25;\n  let h32;\n  let t27;\n  let ul2;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Tournament Format: Double Elimination\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"To ensure fairness and maximize play-time, teams are not eliminated after one loss.\";\n      t3 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li><strong>Upper Bracket:</strong> Teams move forward as long as they win.</li> <li><strong>Lower Bracket (Second Chance):</strong> If a team loses in the Upper Bracket, they drop here. You must win every match in this bracket to stay in the tournament.</li> <li><strong>Elimination:</strong> A team is only eliminated after losing two matches.</li> <li><strong>Match Mode:</strong> All matches are Standard Unrated (First to 13 rounds).</li>`;\n      t15 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Map Selection & Simultaneous Play\";\n      t17 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"To maintain a strict one-day schedule, matches will run simultaneously.\";\n      t19 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li><strong>Organizer Authority:</strong> All maps will be randomly assigned by the Organizers using a randomizer tool. Teams do not ban maps in early rounds to ensure the schedule is maintained.</li> <li><strong>Simultaneous Starts:</strong> Multiple matches will occur at the same time. Team captains must be ready to join the lobby as soon as the Organizer announces the bracket update.</li>`;\n      t25 = space();\n      h32 = element(\"h3\");\n      h32.textContent = \"The Finals (BO1 or BO3)\";\n      t27 = space();\n      ul2 = element(\"ul\");\n      ul2.innerHTML = `<li><strong>Standard Format:</strong> The Grand Finals are intended to be a Best of 3 (Bo3) series.</li> <li><strong>Time Constraint Hint:</strong> The decision to conduct the Finals as a Best of 3 will be made by the Organizers on the spot, subject to the amount of time remaining on the day of the event. If the tournament runs behind schedule, the Finals may be converted to a Best of 1.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t15, anchor);\n      insert(target, h31, anchor);\n      insert(target, t17, anchor);\n      insert(target, p1, anchor);\n      insert(target, t19, anchor);\n      insert(target, ul1, anchor);\n      insert(target, t25, anchor);\n      insert(target, h32, anchor);\n      insert(target, t27, anchor);\n      insert(target, ul2, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(ul0);\n        detach(t15);\n        detach(h31);\n        detach(t17);\n        detach(p1);\n        detach(t19);\n        detach(ul1);\n        detach(t25);\n        detach(h32);\n        detach(t27);\n        detach(ul2);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h30;\n  let t1;\n  let ul0;\n  let t13;\n  let h31;\n  let t15;\n  let ul1;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Match Rules & Judging Criteria\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li><strong>Victory Condition:</strong> The first team to reach 13 rounds.</li> <li><strong>Overtime:</strong> In the event of a 12-12 tie, teams play Overtime (Win by 2), alternating sides.</li> <li><strong>Substitutions:</strong> A team can swap in their registered substitute player only between matches, not during a live game.</li> <li><strong>Technical Pause:</strong> Each team is allowed one 5-minute technical pause per match for connectivity issues.</li>`;\n      t13 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Code of Conduct & Penalties\";\n      t15 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li><strong>Cheating:</strong> Use of third-party software, scripts, or exploits will result in an immediate permanent ban for the entire team.</li> <li><strong>Toxic Behavior:</strong> Insults, slurs, or unsportsmanlike conduct in match chat will result in one warning. A second offense results in disqualification.</li> <li><strong>Organizer Authority:</strong> In case of any dispute or unforeseen technical issue, the Organizer\\u2019s decision is final.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t13, anchor);\n      insert(target, h31, anchor);\n      insert(target, t15, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ul0);\n        detach(t13);\n        detach(h31);\n        detach(t15);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool Distribution\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>1st Place:</strong> \\u20B92,500</li> <li><strong>2nd Place:</strong> \\u20B91,000</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t0;\n  let person1;\n  let t1;\n  let person2;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Mithil\", phone: \"89850 85160\" }\n  });\n  person1 = new Person_default({\n    props: { name: \"Srinivas\", phone: \"82474 12104\" }\n  });\n  person2 = new Person_default({\n    props: {\n      name: \"A . V Siddhartha\",\n      phone: \"+91 63005 41246\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t0 = space();\n      create_component(person1.$$.fragment);\n      t1 = space();\n      create_component(person2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(person1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(person2, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      transition_in(person2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      transition_out(person2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n      destroy_component(person2, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let t2;\n  let p;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n      t2 = space();\n      p = element(\"p\");\n      p.textContent = \"On the day of the event, please follow Admin instructions immediately to ensure a smooth finish.\";\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, p, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(t2);\n        detach(p);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"format\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP29_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_10(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"World Guesser is an exciting geography-based challenge that tests participants\\u2019 observation skills, global knowledge, and logical reasoning. Players are placed at random locations around the world and must accurately guess where they are using visual clues from the surroundings. Speed and precision are the keys to victory.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"The Challenge\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rules & Scoring\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#challenge\",\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h10;\n  let t1;\n  let centersection;\n  let t2;\n  let hr0;\n  let t3;\n  let h11;\n  let t5;\n  let p0;\n  let t9;\n  let p1;\n  let t13;\n  let p2;\n  let t17;\n  let p3;\n  let t21;\n  let p4;\n  let t25;\n  let p5;\n  let t29;\n  let hr1;\n  let t30;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h10 = element(\"h1\");\n      h10.textContent = \"WORLD GUESSER\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      hr0 = element(\"hr\");\n      t3 = space();\n      h11 = element(\"h1\");\n      h11.textContent = \"Event Details\";\n      t5 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Date:</strong> <strong>18th  of January, 9:00AM - 10:30AM</strong>`;\n      t9 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Registration Fee:</strong> <strong>Rs99</strong>`;\n      t13 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Mode:</strong> <strong>Offline</strong>`;\n      t17 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Platform:</strong> <strong>World Guesser (Web-based)</strong>`;\n      t21 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Team Size:</strong> <strong>Individual Participation</strong>`;\n      t25 = space();\n      p5 = element(\"p\");\n      p5.innerHTML = `<strong>Prizes Worth:</strong> <strong>\\u20B910,000 Total</strong>`;\n      t29 = space();\n      hr1 = element(\"hr\");\n      t30 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h10, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, hr0, anchor);\n      insert(target, t3, anchor);\n      insert(target, h11, anchor);\n      insert(target, t5, anchor);\n      insert(target, p0, anchor);\n      insert(target, t9, anchor);\n      insert(target, p1, anchor);\n      insert(target, t13, anchor);\n      insert(target, p2, anchor);\n      insert(target, t17, anchor);\n      insert(target, p3, anchor);\n      insert(target, t21, anchor);\n      insert(target, p4, anchor);\n      insert(target, t25, anchor);\n      insert(target, p5, anchor);\n      insert(target, t29, anchor);\n      insert(target, hr1, anchor);\n      insert(target, t30, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h10);\n        detach(t1);\n        detach(t2);\n        detach(hr0);\n        detach(t3);\n        detach(h11);\n        detach(t5);\n        detach(p0);\n        detach(t9);\n        detach(p1);\n        detach(t13);\n        detach(p2);\n        detach(t17);\n        detach(p3);\n        detach(t21);\n        detach(p4);\n        detach(t25);\n        detach(p5);\n        detach(t29);\n        detach(hr1);\n        detach(t30);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"THE CHALLENGE\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants will be shown random locations from around the world and must guess the correct location using visual clues.</li> <li>Points are awarded based on accuracy and time taken.</li> <li>The event consists of multiple rounds, and the participant with the highest cumulative score wins.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h30;\n  let t1;\n  let ul0;\n  let t13;\n  let h31;\n  let t15;\n  let ul1;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"ELIGIBILITY & RULES\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Open to all registered college students.</li> <li>Each participant can register only once.</li> <li>Internet access is allowed; however, external help is prohibited.</li> <li>Any form of cheating leads to disqualification.</li> <li>Use of VPNs or location spoofing tools is not allowed.</li> <li>Organizers\\u2019 decisions are final.</li>`;\n      t13 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"SCORING SYSTEM\";\n      t15 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Scoring is based on the distance from the actual location and the time taken for each guess.</li> <li>Final rankings are based on the total score across all rounds.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t13, anchor);\n      insert(target, h31, anchor);\n      insert(target, t15, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ul0);\n        detach(t13);\n        detach(h31);\n        detach(t15);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"PRIZES\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>1st Position:</strong> \\u20B95,000</li> <li><strong>2nd Position:</strong> \\u20B93,000</li> <li><strong>3rd Position:</strong> \\u20B92,000</li> <li>Participation certificates will be awarded to all participants.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Aman Meena\", phone: \"9256864676\" }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Rakesh Kumar\",\n      phone: \"8003759174\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let p;\n  let t3;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"For any queries, contact the Event Coordinators:\";\n      t3 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n        detach(t3);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"challenge\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CP30_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_10(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"Gear up for the ultimate survival showdown. The Free Fire tournament at Petrichor \\u201826 is where strategy meets speed. Drop in, secure your loot, and fight to be the last squad standing. Only the most coordinated teams will claim the Booyah and the glory.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Tournament Info\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rules & Conduct\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#format\",\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h10;\n  let t1;\n  let centersection;\n  let t2;\n  let h11;\n  let t4;\n  let p0;\n  let t7;\n  let p1;\n  let t10;\n  let p2;\n  let t13;\n  let p3;\n  let t16;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h10 = element(\"h1\");\n      h10.textContent = \"FREE FIRE\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h11 = element(\"h1\");\n      h11.textContent = \"Event Details\";\n      t4 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Registration Fee:</strong> Rs 49`;\n      t7 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Total Prize Pool:</strong> Rs 3,500`;\n      t10 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Team Size:</strong> 4 Players + 1 Substitute (Optional)`;\n      t13 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Platform:</strong> Mobile Only`;\n      t16 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h10, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h11, anchor);\n      insert(target, t4, anchor);\n      insert(target, p0, anchor);\n      insert(target, t7, anchor);\n      insert(target, p1, anchor);\n      insert(target, t10, anchor);\n      insert(target, p2, anchor);\n      insert(target, t13, anchor);\n      insert(target, p3, anchor);\n      insert(target, t16, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h10);\n        detach(t1);\n        detach(t2);\n        detach(h11);\n        detach(t4);\n        detach(p0);\n        detach(t7);\n        detach(p1);\n        detach(t10);\n        detach(p2);\n        detach(t13);\n        detach(p3);\n        detach(t16);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Tournament Format\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>The tournament features a standard Battle Royale format.</li> <li>All players must ensure that all maps, including Bermuda, Purgatory, and Kalahari, are fully downloaded before the event starts.</li> <li>Specific match schedules and map rotations will be provided by the administrators on the day of the event.</li> <li>The tournament is open to all students; cross-college teams are permitted.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h30;\n  let t1;\n  let ul0;\n  let t11;\n  let h31;\n  let t13;\n  let ul1;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Gameplay & Device Rules\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Matches must be played on mobile devices only (Android/iOS).</li> <li>The use of emulators, tablets, or any third-party software/hacks is strictly prohibited and will lead to an immediate ban.</li> <li>External hardware such as triggers, gamepads, or specialized gaming accessories are not allowed.</li> <li>Participants are responsible for their own internet connection. Matches will not be paused or restarted due to individual lag or disconnections.</li> <li>Teaming with other squads, intentional feeding, or exploitation of in-game bugs is strictly forbidden.</li>`;\n      t11 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Conduct & Penalties\";\n      t13 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>All participants must adhere to the principles of fair play and sportsmanship.</li> <li>Toxic behavior, verbal abuse, or harassment will result in point deductions or disqualification at the discretion of the organizers.</li> <li>Any disputes must be reported immediately with valid proof (recorded gameplay or screenshots).</li> <li>The decisions made by the tournament organizers and referees are final and binding.</li> <li>Failure to follow Admin instructions in the lobby will lead to a team kick or disqualification.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t11, anchor);\n      insert(target, h31, anchor);\n      insert(target, t13, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ul0);\n        detach(t11);\n        detach(h31);\n        detach(t13);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool Distribution\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>1st Place:</strong> \\u20B92,500</li> <li><strong>2nd Place:</strong> \\u20B91,000</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Mithil\", phone: \"89850 85160\" }\n  });\n  person1 = new Person_default({\n    props: { name: \"Vighnith\", phone: \"85005 18562\" }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let p;\n  let t3;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"For any queries, contact the coordinators:\";\n      t3 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n        detach(t3);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"format\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CP31_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_10(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"The Clash Royale Tournament is organized to ensure fair, competitive, and well-structured gameplay. The event is played on mobile using friendly battles under tournament standards. Eligible players compete in a Swiss-format qualifier followed by a double elimination finals bracket.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Tournament Structure\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rules & Conduct\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#format\",\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h1;\n  let t1;\n  let centersection;\n  let t2;\n  let h2;\n  let t4;\n  let p0;\n  let t8;\n  let p1;\n  let t12;\n  let p2;\n  let t16;\n  let p3;\n  let t20;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"CLASH ROYALE\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h2 = element(\"h2\");\n      h2.textContent = \"Event Details\";\n      t4 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Registration Fee:</strong> <strong>\\u20B949</strong>`;\n      t8 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Total Prize Pool:</strong> <strong>Rs. 3,500</strong>`;\n      t12 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Team Size:</strong> <strong>Individual (1 Member)</strong>`;\n      t16 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Mode:</strong> <strong>Mobile (Friendly Battles)</strong>`;\n      t20 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h2, anchor);\n      insert(target, t4, anchor);\n      insert(target, p0, anchor);\n      insert(target, t8, anchor);\n      insert(target, p1, anchor);\n      insert(target, t12, anchor);\n      insert(target, p2, anchor);\n      insert(target, t16, anchor);\n      insert(target, p3, anchor);\n      insert(target, t20, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(t2);\n        detach(h2);\n        detach(t4);\n        detach(p0);\n        detach(t8);\n        detach(p1);\n        detach(t12);\n        detach(p2);\n        detach(t16);\n        detach(p3);\n        detach(t20);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h30;\n  let t1;\n  let ul0;\n  let t7;\n  let h31;\n  let t9;\n  let ul1;\n  let t15;\n  let h32;\n  let t17;\n  let ul2;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Tournament Phases\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li><strong>Phase 1: Swiss Qualifier Stage</strong> \\u2013 Initial round to determine seeding and finalists.</li> <li><strong>Phase 2: Double Elimination Finals</strong> \\u2013 The top players compete in a bracket where they must lose twice to be eliminated.</li>`;\n      t7 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Match Formats\";\n      t9 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li><strong>Non-Final Matches:</strong> All Upper and Lower Bracket matches (except finals) are single-game matches using any deck of choice.</li> <li><strong>Final Matches:</strong> The Upper Bracket Final, Lower Bracket Final, and Grand Final use a Best of 3 format.</li>`;\n      t15 = space();\n      h32 = element(\"h3\");\n      h32.textContent = \"Best of 3 Rules\";\n      t17 = space();\n      ul2 = element(\"ul\");\n      ul2.innerHTML = `<li><strong>Game 1:</strong> Free deck choice.</li> <li><strong>Game 2:</strong> Unique deck (must be different from Game 1).</li> <li><strong>Game 3:</strong> Mega Draft mode.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t7, anchor);\n      insert(target, h31, anchor);\n      insert(target, t9, anchor);\n      insert(target, ul1, anchor);\n      insert(target, t15, anchor);\n      insert(target, h32, anchor);\n      insert(target, t17, anchor);\n      insert(target, ul2, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ul0);\n        detach(t7);\n        detach(h31);\n        detach(t9);\n        detach(ul1);\n        detach(t15);\n        detach(h32);\n        detach(t17);\n        detach(ul2);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h30;\n  let t1;\n  let ul0;\n  let t10;\n  let h31;\n  let t12;\n  let ul1;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Player Eligibility\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li><strong>Trophy Requirement:</strong> Players must have a minimum of 4000 trophies.</li> <li><strong>Account Policy:</strong> Only one account per player is permitted.</li> <li><strong>Fair Play:</strong> Any form of cheating, account sharing, or exploitation results in immediate disqualification.</li>`;\n      t10 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Conduct and Disputes\";\n      t12 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li><strong>Fair Play:</strong> Players must respect opponents and staff. Toxic behavior may result in penalties or disqualification.</li> <li><strong>Disputes:</strong> Players must provide screenshots or match replays if disputes arise.</li> <li><strong>Organizer Authority:</strong> The organizer\\u2019s decision is final in all unforeseen situations.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t10, anchor);\n      insert(target, h31, anchor);\n      insert(target, t12, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ul0);\n        detach(t10);\n        detach(h31);\n        detach(t12);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool Distribution\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>1st Place:</strong> \\u20B92,500</li> <li><strong>2nd Place:</strong> \\u20B91,000</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t0;\n  let person1;\n  let t1;\n  let person2;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Mithil\", phone: \"89850 85160\" }\n  });\n  person1 = new Person_default({\n    props: { name: \"Yasaswi\", phone: \"90327 47475\" }\n  });\n  person2 = new Person_default({\n    props: { name: \"Sai Rohan\", phone: \"80744 02321\" }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t0 = space();\n      create_component(person1.$$.fragment);\n      t1 = space();\n      create_component(person2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(person1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(person2, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      transition_in(person2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      transition_out(person2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n      destroy_component(person2, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let flexsection;\n  let t4;\n  let p1;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"For clarifications and support:\";\n      t3 = space();\n      create_component(flexsection.$$.fragment);\n      t4 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<em>Clarifications are accepted until the day before the event. On the day of the event, follow Admin instructions immediately to ensure a smooth finish.</em>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      mount_component(flexsection, target, anchor);\n      insert(target, t4, anchor);\n      insert(target, p1, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(t4);\n        detach(p1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"format\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP43_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_9(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"Step into a high-intensity offline stock trading simulation designed to test your financial acumen, strategy, and decision-making under market pressure. Navigate simulated market dynamics and breaking news to build the most valuable portfolio and dominate the trading floor.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Event Format\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rules & Scoring\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#format\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let centersection;\n  let t2;\n  let p0;\n  let t6;\n  let p1;\n  let t9;\n  let p2;\n  let t12;\n  let p3;\n  let t15;\n  let p4;\n  let t18;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"ALGOZEN\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Date:</strong> <strong>18th  of January, 9:00AM -12:00PM</strong>`;\n      t6 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Prizes Worth:</strong> Rs 10,000`;\n      t9 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Registration fee:</strong> Rs. 99 per Head`;\n      t12 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Team Size:</strong> 1\\u20133 Members`;\n      t15 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Format:</strong> Offline Simulation`;\n      t18 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, p0, anchor);\n      insert(target, t6, anchor);\n      insert(target, p1, anchor);\n      insert(target, t9, anchor);\n      insert(target, p2, anchor);\n      insert(target, t12, anchor);\n      insert(target, p3, anchor);\n      insert(target, t15, anchor);\n      insert(target, p4, anchor);\n      insert(target, t18, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(t2);\n        detach(p0);\n        detach(t6);\n        detach(p1);\n        detach(t9);\n        detach(p2);\n        detach(t12);\n        detach(p3);\n        detach(t15);\n        detach(p4);\n        detach(t18);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Event Format\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Each team begins with a virtual capital of \\u20B910,00,000.</li> <li>Trading involves a curated list of fictional stocks across sectors like technology, energy, banking, and pharma.</li> <li>Stock prices evolve in real-time based on simulated news, corporate announcements, and global events.</li> <li>The event spans approximately 2 hours, divided into multiple active trading sessions.</li> <li>Portfolios are evaluated based on the last announced market rates once trading concludes.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h30;\n  let t1;\n  let ul0;\n  let t13;\n  let h31;\n  let t15;\n  let ul1;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Eligibility and Rules\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Open to all undergraduate and postgraduate students from recognized institutions.</li> <li>Participants must present a valid college ID card at the on-site registration desk.</li> <li>Teams can consist of 1 to 3 members from the same or different colleges.</li> <li>Use of electronic devices or external aids during sessions is strictly prohibited unless specifically permitted.</li> <li>Participants must follow all moderator instructions and maintain clear records of their transactions.</li> <li>The organizing team reserves the right to amend rules or schedules due to unforeseen circumstances.</li>`;\n      t13 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Scoring and Evaluation\";\n      t15 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Winner is determined by the highest Total Portfolio Value (Cash Balance + Market Value of Holdings).</li> <li>In case of a tie, the participant with a more diversified portfolio will rank higher.</li> <li>If still tied, the team that reached their final portfolio value earlier according to the logs will be placed higher.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t13, anchor);\n      insert(target, h31, anchor);\n      insert(target, t15, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ul0);\n        detach(t13);\n        detach(h31);\n        detach(t15);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Divyanshu\", phone: \"7060716746\" }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Mradul Dwivedi\",\n      phone: \"91406 52930\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let flexsection;\n  let t4;\n  let p1;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"For any queries regarding the trading simulation, contact the coordinators:\";\n      t3 = space();\n      create_component(flexsection.$$.fragment);\n      t4 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"All participants will receive certificates of participation, and winners will receive Certificates of Achievement.\";\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      mount_component(flexsection, target, anchor);\n      insert(target, t4, anchor);\n      insert(target, p1, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(t4);\n        detach(p1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"format\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CF33_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_10(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"An individual event where participants will write a poetry of 100 - 200 words in English or Hindi based on the given prompts.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rules & Guidelines\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Judging Criteria\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#judging\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h1;\n  let t1;\n  let centersection;\n  let t2;\n  let h2;\n  let t4;\n  let p0;\n  let t7;\n  let p1;\n  let t10;\n  let p2;\n  let t13;\n  let p3;\n  let t17;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"KAVYA\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h2 = element(\"h2\");\n      h2.textContent = \"Event Details\";\n      t4 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Word Limit:</strong> 200 words`;\n      t7 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Language:</strong> English or Hindi`;\n      t10 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Submission:</strong> Single entry per participant`;\n      t13 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Submission Link:</strong> <a href=\"https://forms.gle/MA7QFbdVqkDcoNJd6\" target=\"_blank\">Click Here</a>`;\n      t17 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h2, anchor);\n      insert(target, t4, anchor);\n      insert(target, p0, anchor);\n      insert(target, t7, anchor);\n      insert(target, p1, anchor);\n      insert(target, t10, anchor);\n      insert(target, p2, anchor);\n      insert(target, t13, anchor);\n      insert(target, p3, anchor);\n      insert(target, t17, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(t2);\n        detach(h2);\n        detach(t4);\n        detach(p0);\n        detach(t7);\n        detach(p1);\n        detach(t10);\n        detach(p2);\n        detach(t13);\n        detach(p3);\n        detach(t17);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h2;\n  let t1;\n  let ol;\n  return {\n    c() {\n      h2 = element(\"h2\");\n      h2.textContent = \"Prompts\";\n      t1 = space();\n      ol = element(\"ol\");\n      ol.innerHTML = `<li>The Courage it takes to simply exist</li> <li>To the unseen Cupids shaping hearts</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h2, anchor);\n      insert(target, t1, anchor);\n      insert(target, ol, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h2);\n        detach(t1);\n        detach(ol);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Competition Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>The poem should not exceed the word limit of 200 words.</li> <li>The poem must be based on the prompts provided.</li> <li>The entry must be in English or Hindi.</li> <li>Every entry must have a title.</li> <li>The use of language should be careful. No part of the society or individual should be offended.</li> <li>Only one submission is allowed per participant.</li> <li>The entry must be the original work of the participant, and must not have been published elsewhere.</li> <li>All the entries must be sent in a particular format (Name of Poem_Name of participant).</li> <li>Illustrations such as graphs and sketches are not allowed.</li> <li>The poems submitted before the deadline will only be considered for results.</li> <li>Plagiarism and use of explicit content will lead to immediate disqualification.</li> <li>The decisions made by the judges are final. Requests to reconsider the final decision will not be entertained.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Judging Criteria\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Creativity: 35</li> <li>Originality: 35</li> <li>Relevance to Theme: 30</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person;\n  let current;\n  person = new Person_default({\n    props: { name: \"Bhoomika\", phone: \"9633054731\" }\n  });\n  return {\n    c() {\n      create_component(person.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(person, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let p;\n  let t3;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"For any queries, contact the coordinators:\";\n      t3 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n        detach(t3);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"prompts\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"judging\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP39_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h1;\n  let t1;\n  let h3;\n  let t3;\n  let p0;\n  let t5;\n  let p1;\n  let t8;\n  let p2;\n  let t11;\n  let p3;\n  let t14;\n  let p4;\n  let t17;\n  let p5;\n  let t20;\n  let p6;\n  let t23;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"IC-Vision 2026\";\n      t1 = space();\n      h3 = element(\"h3\");\n      h3.textContent = \"Development of Analog IC Tester\";\n      t3 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"Analog ICs such as op-amps, transistors, and instrumentation amplifiers are essential in lab environments, yet they often lack a reliable verification method after repeated use. This competition challenges participants to design a dedicated Analog IC Tester capable of performing quick and reliable functional tests on common analog ICs without the need for breadboard setups or external lab instruments.\";\n      t5 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Date:</strong> 15th - 17th of January`;\n      t8 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Target ICs:</strong> CD4007, LM741, and AD621`;\n      t11 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Registration Fee:</strong> Rs 99`;\n      t14 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Mode</strong> : Online`;\n      t17 = space();\n      p5 = element(\"p\");\n      p5.innerHTML = `<strong>Prize Worth:</strong> Rs. 10000`;\n      t20 = space();\n      p6 = element(\"p\");\n      p6.innerHTML = `<strong>Participation Limit:</strong> 2 - 4 members per team`;\n      t23 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, h3, anchor);\n      insert(target, t3, anchor);\n      insert(target, p0, anchor);\n      insert(target, t5, anchor);\n      insert(target, p1, anchor);\n      insert(target, t8, anchor);\n      insert(target, p2, anchor);\n      insert(target, t11, anchor);\n      insert(target, p3, anchor);\n      insert(target, t14, anchor);\n      insert(target, p4, anchor);\n      insert(target, t17, anchor);\n      insert(target, p5, anchor);\n      insert(target, t20, anchor);\n      insert(target, p6, anchor);\n      insert(target, t23, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(h3);\n        detach(t3);\n        detach(p0);\n        detach(t5);\n        detach(p1);\n        detach(t8);\n        detach(p2);\n        detach(t11);\n        detach(p3);\n        detach(t14);\n        detach(p4);\n        detach(t17);\n        detach(p5);\n        detach(t20);\n        detach(p6);\n        detach(t23);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Methodology\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Study the electrical characteristics of each target IC from its datasheet to determine absolute maximum voltage levels.</li> <li>Design specific test configurations for each IC and establish clear PASS/FAIL criteria.</li> <li>Simulate the designed circuits using industry-standard software such as LT-SPICE or PSpice.</li> <li>Develop an efficient mechanism to multiplex between test circuits and simulate the integrated system.</li> <li>Select appropriate IC sockets or ZIF holders to facilitate easy insertion and prevent pin damage.</li> <li>Choose a microcontroller with adequate ADC resolution, DAC/PWM capabilities, and GPIO count.</li> <li>Design a professional PCB layout, ensuring accessibility for sockets, buttons, and displays.</li> <li>Develop a custom enclosure to house the PCB and finalize the system design.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let p;\n  let t3;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Deliverables\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"All submission files must be contained within a .zip folder including:\";\n      t3 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Complete test circuit schematics and simulation files.</li> <li>Final PCB design files.</li> <li>A detailed Bill of Materials (BOM) including part numbers and estimated costs.</li> <li>A 3D model of the enclosure design in .step format.</li> <li>A comprehensive design report documenting the project approach and switching strategies.</li> <li>High-quality screenshots of the schematics, PCB layers, and the enclosure 3D model.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p);\n        detach(t3);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let p;\n  let t3;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Evaluation Criteria\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"Total Marks: 100\";\n      t3 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Test Circuit Design and Simulation: 45 Marks</li> <li>Component Selection: 20 Marks</li> <li>Multiplexing Strategy Study and Selection: 15 Marks</li> <li>PCB Design: 10 Marks</li> <li>Enclosure Design: 10 Marks</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p);\n        detach(t3);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person;\n  let current;\n  person = new Person_default({\n    props: {\n      name: \"Sidharth Saji\",\n      phone: \"9605517615\"\n    }\n  });\n  return {\n    c() {\n      create_component(person.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(person, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizers\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"judging\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP19_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t7;\n  let p2;\n  let t12;\n  let p3;\n  let t15;\n  let p4;\n  let t18;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"MeshWars\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"MeshWars is a high-stakes, online 3D art competition. Participants will have exactly six hours to create a single, breathtaking 3D render from scratch based on a theme announced at the start. This is a pure test of imagination, skill, and speed.\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Date:</strong> <strong>18th  of January, 9:00AM - 3:00PM</strong>`;\n      t7 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Resgistraion Fee:</strong> <strong>Rs 99</strong> per Head`;\n      t12 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Mode</strong>: Online`;\n      t15 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Prizes Worth:</strong> Rs 15000`;\n      t18 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t7, anchor);\n      insert(target, p2, anchor);\n      insert(target, t12, anchor);\n      insert(target, p3, anchor);\n      insert(target, t15, anchor);\n      insert(target, p4, anchor);\n      insert(target, t18, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t7);\n        detach(p2);\n        detach(t12);\n        detach(p3);\n        detach(t15);\n        detach(p4);\n        detach(t18);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Eligibility & Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Originality: All designs must be original and created during the event.</li> <li>Assets: Use of personal assets and previous designs is allowed, but must be mentioned at the time of submission.</li> <li>No Obscenity: Submissions must not contain any offensive, obscene, or hateful content.</li> <li>Theme Adherence: All submissions must adhere to the competition theme, announced before the event.</li> <li>Submission Limit: Only one final render per participant.</li> <li>Internet Usage: The Internet is allowed for research, references, and textures but not for downloading 3D scenes.</li> <li>No AI: No AI-generated renders or models are allowed.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let p0;\n  let t3;\n  let ul0;\n  let t11;\n  let p1;\n  let t13;\n  let ul1;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"The Challenge & Submission\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Requirements:</strong>`;\n      t3 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Any 3D rendering software is allowed (Blender, Fusion 360, etc.).</li> <li>Screenshots of the work windows should be captured with the timestamp visible and submitted at regular intervals.</li> <li>The final submission must include the final rendered image and raw file (.blend, .c4d, .max, .mb etc.).</li> <li>Minimum resolution: 1920x1080 (HD) in .png or .jpg formats.</li>`;\n      t11 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Format:</strong>`;\n      t13 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Mode: Online.</li> <li>Duration: 6 hours.</li> <li>Pre-made textures are allowed, but procedural texture and node setups will also be judged.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t11, anchor);\n      insert(target, p1, anchor);\n      insert(target, t13, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(ul0);\n        detach(t11);\n        detach(p1);\n        detach(t13);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>1st Position: Rs 7000</li> <li>2nd Position: Rs 5000</li> <li>3rd Position: Rs 3000</li> <li>Participation certificates will be awarded to all participants.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: {\n      name: \"Kalakuntla Parjanya\",\n      phone: \"8367231921\"\n    }\n  });\n  person1 = new Person_default({\n    props: { name: \"Akshat\", phone: \"8129831532\" }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizers\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP18_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t7;\n  let p2;\n  let t12;\n  let p3;\n  let t15;\n  let p4;\n  let t18;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Wikirun\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"Step into a race through the digital library of human history! This high-speed navigation challenge tests your ability to find connections between seemingly unrelated topics using only internal Wikipedia hyperlinks.\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Date:</strong> <strong>17th  of January, 6:00PM - 9:00PM</strong>`;\n      t7 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Registration Fee:</strong> <strong>Rs 99</strong> per Head`;\n      t12 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Mode</strong>: Online`;\n      t15 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Prizes Worth :</strong> Rs 10000`;\n      t18 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t7, anchor);\n      insert(target, p2, anchor);\n      insert(target, t12, anchor);\n      insert(target, p3, anchor);\n      insert(target, t15, anchor);\n      insert(target, p4, anchor);\n      insert(target, t18, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t7);\n        detach(p2);\n        detach(t12);\n        detach(p3);\n        detach(t15);\n        detach(p4);\n        detach(t18);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"General Guidelines\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants per team: Maximum 1.</li> <li>Total Duration: 2 Hours.</li> <li>Core Objective: Navigate from a starting Wikipedia page to a target page using only internal hyperlinks.</li> <li>Navigation: Participants may go back to the previous page if required.</li> <li>Use of any site other than Wikipedia will result in immediate disqualification.</li> <li>A webcam and stable internet connection are required at all times; participants will be monitored and recorded.</li> <li>External assistance or any foul play will result in immediate disqualification.</li> <li>In case of disputes, the organizer&#39;s decision will be final.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let p0;\n  let t3;\n  let ul0;\n  let t9;\n  let p1;\n  let t11;\n  let ul1;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Event Format\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Round 1</strong>`;\n      t3 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Duration: 30 Minutes.</li> <li>Winning Condition: The participant to complete the task within the fastest time possible wins.</li> <li>Qualification: Only the fastest 5 participants qualify for the next round.</li>`;\n      t9 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Round 2</strong>`;\n      t11 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Duration: 1.5 Hours.</li> <li>Winning Condition: The participant to complete the task by travelling through the least number of web pages wins.</li> <li>Counting: Every page will be counted, even if a participant returns to a previous page.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t9, anchor);\n      insert(target, p1, anchor);\n      insert(target, t11, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(ul0);\n        detach(t9);\n        detach(p1);\n        detach(t11);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>First Prize: 4,000</li> <li>Second Prize: 3,000</li> <li>Third Prize: 2,000</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Athira S J\", phone: \"9446665640\" }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Aaditya Dinesh\",\n      phone: \"9645399933\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizers\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP30_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_10(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"Cipherify is a thrilling Capture the Flag (CTF) event where the participants are expected to showcase their cybersecurity, problem-solving, and hacking skills in a competitive and time-sensitive environment. Whether you are a beginner or an experienced elite, the event will feature challenges across categories like cryptography, reverse engineering, web exploitation, forensics, and more. The goal is simple: get the flag, find the hidden \\u201Cflags,\\u201D and earn points to climb the leaderboard.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Description\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Full Rules\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#description\",\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h10;\n  let t1;\n  let centersection;\n  let t2;\n  let h11;\n  let t4;\n  let p0;\n  let t8;\n  let p1;\n  let t12;\n  let p2;\n  let t17;\n  let p3;\n  let t20;\n  let p4;\n  let t24;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h10 = element(\"h1\");\n      h10.textContent = \"Capture the Flag: Cipherify\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h11 = element(\"h1\");\n      h11.textContent = \"Event Details\";\n      t4 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Date:</strong> <strong>17th  of January, 3PM - 6PM</strong>`;\n      t8 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Duration:</strong> <strong>3 hours</strong>`;\n      t12 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Resgistraion Fee:</strong> <strong>Rs 99</strong> per Head`;\n      t17 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Mode</strong>: Online`;\n      t20 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Prizes Worth:</strong> <strong>\\u20B920,000 Total</strong>`;\n      t24 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h10, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h11, anchor);\n      insert(target, t4, anchor);\n      insert(target, p0, anchor);\n      insert(target, t8, anchor);\n      insert(target, p1, anchor);\n      insert(target, t12, anchor);\n      insert(target, p2, anchor);\n      insert(target, t17, anchor);\n      insert(target, p3, anchor);\n      insert(target, t20, anchor);\n      insert(target, p4, anchor);\n      insert(target, t24, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h10);\n        detach(t1);\n        detach(t2);\n        detach(h11);\n        detach(t4);\n        detach(p0);\n        detach(t8);\n        detach(p1);\n        detach(t12);\n        detach(p2);\n        detach(t17);\n        detach(p3);\n        detach(t20);\n        detach(p4);\n        detach(t24);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Introduction & Goals\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Cipherify promises a unique experience whether you are a solo player or part of a team.</li> <li>This competition will challenge your technical expertise, analytical thinking, and teamwork.</li> <li>The CTF will be jeopardy-style.</li> <li>Challenges are hosted on a DigitalOcean server (Minimum 4 vCPU, 8GB RAM) using Docker for security and portability.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h30;\n  let t1;\n  let ul0;\n  let t9;\n  let h31;\n  let t11;\n  let ul1;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Eligibility & Participation\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Participants may register individually or in teams of up to 2 members.</li> <li>No registration fee should be paid.</li> <li>Participation certificates will be awarded to all participants.</li> <li>The platform for the CTF and credentials will be mailed to registered participants a week before the event.</li>`;\n      t9 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"General Rules\";\n      t11 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Sharing of flags to other teams is not allowed.</li> <li>In case of any discrepancy, the decision of the event coordinators will be considered final.</li> <li>All challenges will be containerized using Docker.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t9, anchor);\n      insert(target, h31, anchor);\n      insert(target, t11, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ul0);\n        detach(t9);\n        detach(h31);\n        detach(t11);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Money\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>1st Prize:</strong> \\u20B910,000</li> <li><strong>2nd Prize:</strong> \\u20B96,000</li> <li><strong>3rd Prize:</strong> \\u20B94,000</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Yazeed\", phone: \"8593930099\" }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Kalakuntla Parjanya\",\n      phone: \"8367231921\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let p;\n  let t3;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      p = element(\"p\");\n      p.innerHTML = `<strong>Event Coordinators:</strong>`;\n      t3 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n        detach(t3);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"description\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CF27_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_10(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rules\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Format\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#structure\",\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let h1;\n  let t1;\n  let h3;\n  let t3;\n  let p0;\n  let t5;\n  let h2;\n  let t7;\n  let p1;\n  let t10;\n  let p2;\n  let t13;\n  let p3;\n  let t16;\n  let p4;\n  let t20;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Vogue Wars\";\n      t1 = space();\n      h3 = element(\"h3\");\n      h3.textContent = \"Group Fashion Show\";\n      t3 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"Get ready to experience the vibrant spirit of Petrichor 2k26. This is a platform for fashion enthusiasts to showcase style, creativity, and poise.\";\n      t5 = space();\n      h2 = element(\"h2\");\n      h2.textContent = \"Event Details\";\n      t7 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Registration fee:</strong> Rs. 179`;\n      t10 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Prizes Worth:</strong> Rs. 25k`;\n      t13 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Team Size:</strong> 1 - 15 members`;\n      t16 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Submission Link for Round 1:</strong> <a href=\"https://forms.gle/UM9nHkg9YTBy6V3m9\" target=\"_blank\">Click Here</a>`;\n      t20 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, h3, anchor);\n      insert(target, t3, anchor);\n      insert(target, p0, anchor);\n      insert(target, t5, anchor);\n      insert(target, h2, anchor);\n      insert(target, t7, anchor);\n      insert(target, p1, anchor);\n      insert(target, t10, anchor);\n      insert(target, p2, anchor);\n      insert(target, t13, anchor);\n      insert(target, p3, anchor);\n      insert(target, t16, anchor);\n      insert(target, p4, anchor);\n      insert(target, t20, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(h3);\n        detach(t3);\n        detach(p0);\n        detach(t5);\n        detach(h2);\n        detach(t7);\n        detach(p1);\n        detach(t10);\n        detach(p2);\n        detach(t13);\n        detach(p3);\n        detach(t16);\n        detach(p4);\n        detach(t20);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules and Regulations\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>A group can have a maximum of 15 members, which includes at most 10 models walking the ramp.</li> <li>Time Limit: Each team is allotted a strictly monitored slot of 10 minutes, including stage setup, performance, and clearing the stage.</li> <li>Stunts posing any risk to life or safety are not permitted.</li> <li>Inflammable objects and heavy props are strictly prohibited.</li> <li>Vulgarity in any form (attire or action) is strictly prohibited and will lead to disqualification.</li> <li>Teams are responsible for the condition of the stage; the stage must be restored to its original state within the 10-minute limit if confetti or props are used.</li> <li>Live narration is permitted during the performance.</li> <li>Teams must submit their audio tracks (MP3 format) at least 1 hour prior to the event.</li> <li>Teams must inform the organiser about their chosen theme at least 1 hour prior to their performance.</li> <li>Green room access is restricted to participants only.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let p0;\n  let t4;\n  let p1;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Event Format\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Round One (Online Submission):</strong> Teams are required to post an audiovisual recording of their performance via the google form on Petrichor\\u2019s website.`;\n      t4 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Round Two (Main Performance):</strong> Selected entries will perform live on stage during Petrichor.`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t4, anchor);\n      insert(target, p1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p0);\n        detach(t4);\n        detach(p1);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let p;\n  let t3;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Judging Criteria\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"The decision of the judges is final and binding. Scoring is based on the following:\";\n      t3 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Theme Relevance: Adherence to the chosen theme.</li> <li>Performance: Ramp Walk, Choreography, and Stage Presence.</li> <li>Aesthetics: Costumes and Overall Impact.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p);\n        detach(t3);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool Distribution\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>1st Place:</strong> \\u20B915,000</li> <li><strong>2nd Place:</strong> \\u20B910,000</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person;\n  let current;\n  person = new Person_default({\n    props: { name: \"Vedant\", phone: \"7905499069\" }\n  });\n  return {\n    c() {\n      create_component(person.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(person, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let section3;\n  let t4;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"judging\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section3 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(section3.$$.fragment);\n      t4 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(section3, target, anchor);\n      insert(target, t4, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const section3_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section3_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section3.$set(section3_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(section3.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(section3.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n        detach(t4);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(section3, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CP28_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let h2;\n  let t5;\n  let p1;\n  let t9;\n  let p2;\n  let t12;\n  let p3;\n  let t15;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Face Painting\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"Unleash your creativity in this artistic challenge where the face becomes a canvas.\";\n      t3 = space();\n      h2 = element(\"h2\");\n      h2.textContent = \"Event Details\";\n      t5 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Registration Fee:</strong> <strong>\\u20B949</strong>`;\n      t9 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Team Size:</strong> 2 members`;\n      t12 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Total Prize pool:</strong> Rs. 3000`;\n      t15 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, h2, anchor);\n      insert(target, t5, anchor);\n      insert(target, p1, anchor);\n      insert(target, t9, anchor);\n      insert(target, p2, anchor);\n      insert(target, t12, anchor);\n      insert(target, p3, anchor);\n      insert(target, t15, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(h2);\n        detach(t5);\n        detach(p1);\n        detach(t9);\n        detach(p2);\n        detach(t12);\n        detach(p3);\n        detach(t15);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Each team may consist of no more than two members.</li> <li>The painting must be completed within 60 minutes.</li> <li>Brushes and paintings will be provided.</li> <li>Contestants must use the materials provided; no additional tools or items are permitted unless specified by the event organizers.</li> <li>No part of the design may be applied to the model&#39;s face before the official start time.</li> <li>The time clock will begin once the competition period starts.</li> <li>The topic for the painting will be informed to all participants before the event begins.</li> <li>Contestants are expected to adhere to the given theme.</li> <li>The design may not extend down the neck or onto the model&#39;s chest, shoulders, or back area. Only the face is to be used.</li> <li>The model&#39;s hair may be clipped or pinned back to fully expose the design area.</li> <li>Contestants should ensure the hair does not obstruct the painting surface.</li> <li>The design should be appropriate and respectful of the event&#39;s standards and audience. No offensive or inappropriate content will be allowed.</li> <li>The design must stay within the specified design area. Designs that exceed the allowed area will be disqualified.</li> <li>Only the two team members are allowed to participate in the creation of the design.</li> <li>No outside help or third-party assistance is permitted during the competition period.</li> <li>Contestants must maintain a clean workspace and ensure no materials are left in hazardous areas.</li> <li>All brushes, paints, and supplies should be stored properly after use.</li> <li>Any violation of the above rules may lead to disqualification.</li> <li>The organizers reserve the right to remove any team that fails to follow the guidelines.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let p;\n  let t3;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Judging Criteria\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"Participants will be judged on originality, concept, painting skills, composition overall impact, and creativity.\";\n      t3 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Adherence/Appropriateness to Theme: (25%)</li> <li>Originality and Creativity: (25%)</li> <li>Overall Artistic Impression and visual impact: (25%)</li> <li>Painting Skills (difficulty of design and technique): (25%)</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p);\n        detach(t3);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool Distribution\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>1st Place:</strong> \\u20B92,000</li> <li><strong>2nd Place:</strong> \\u20B91,000</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person;\n  let current;\n  person = new Person_default({\n    props: { name: \"Julekhya\", phone: \"9392394687\" }\n  });\n  return {\n    c() {\n      create_component(person.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(person, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"judging\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CP24_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_9(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"We\\u2019ve got questions that cover the full spectrum. Brush up on your sports stats and pop culture facts for the Petrichor Sp-Ent Quiz. Expect curveballs, blockbusters, and a battle of wits!\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rules & Format\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h10;\n  let t1;\n  let centersection;\n  let t2;\n  let h11;\n  let t4;\n  let p0;\n  let t7;\n  let p1;\n  let t10;\n  let p2;\n  let t14;\n  let p3;\n  let t18;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h10 = element(\"h1\");\n      h10.textContent = \"SP-ENT Quiz\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h11 = element(\"h1\");\n      h11.textContent = \"Event Details\";\n      t4 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Prizes worth:</strong> Rs. 2.5k`;\n      t7 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Registration Fee:</strong> Rs. 49`;\n      t10 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>No of participants in each team:</strong> <strong>Max 3</strong>`;\n      t14 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Event open for:</strong> <strong>College</strong>`;\n      t18 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h10, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h11, anchor);\n      insert(target, t4, anchor);\n      insert(target, p0, anchor);\n      insert(target, t7, anchor);\n      insert(target, p1, anchor);\n      insert(target, t10, anchor);\n      insert(target, p2, anchor);\n      insert(target, t14, anchor);\n      insert(target, p3, anchor);\n      insert(target, t18, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h10);\n        detach(t1);\n        detach(t2);\n        detach(h11);\n        detach(t4);\n        detach(p0);\n        detach(t7);\n        detach(p1);\n        detach(t10);\n        detach(p2);\n        detach(t14);\n        detach(p3);\n        detach(t18);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Teams consist of at most three participants.</li> <li>Teams should arrive at least 30 mins before the start of the event for verification.</li> <li>Prelims will be in written format. Papers will be provided. It is advised to bring your own pens.</li> <li>Engaging in any kind of malpractice will lead to disqualification.</li> <li>The decision taken by the quizmasters will be final and binding.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Format\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>The quiz consists of two rounds: prelims and finals.</li> <li>The top 8 teams from the preliminary round will qualify for the finals.</li> <li>Finals will be on-stage.</li> <li>The general bounce and pounce system will be followed for finals (will be further explained on-spot).</li> <li>Round-specific rules will be explained on the spot.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool Distribution\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>1st Place:</strong> \\u20B91500</li> <li><strong>2nd Place:</strong> \\u20B91000</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person;\n  let current;\n  person = new Person_default({\n    props: { name: \"Adinath\", phone: \"7902220690\" }\n  });\n  return {\n    c() {\n      create_component(person.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(person, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"format\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CP18_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_8(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"Focus is on creativity, teamwork, and adaptability.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rules & Guidelines\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let centersection;\n  let t2;\n  let h2;\n  let t4;\n  let p0;\n  let t8;\n  let p1;\n  let t12;\n  let p2;\n  let t16;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Theme Painting\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h2 = element(\"h2\");\n      h2.textContent = \"Event Details\";\n      t4 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Registration Fee:</strong> <strong>Rs. 49 per person</strong>`;\n      t8 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Team Size:</strong> <strong>2 or 3 participants</strong>`;\n      t12 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Total Prize Pool:</strong> <strong>Rs. 3500</strong>`;\n      t16 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h2, anchor);\n      insert(target, t4, anchor);\n      insert(target, p0, anchor);\n      insert(target, t8, anchor);\n      insert(target, p1, anchor);\n      insert(target, t12, anchor);\n      insert(target, p2, anchor);\n      insert(target, t16, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(t2);\n        detach(h2);\n        detach(t4);\n        detach(p0);\n        detach(t8);\n        detach(p1);\n        detach(t12);\n        detach(p2);\n        detach(t16);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Each team must consist of 2 or 3 participants.</li> <li>The painting must be completed within 60 minutes.</li> <li>Brushes and paintings will be provided. Contestants must use the materials provided; no additional tools or items are permitted unless specified by the event organizers.</li> <li>The topic for the painting will be informed to all participants before the event begins. Contestants are expected to adhere to the given theme.</li> <li>Teams must strictly follow the theme throughout the artwork.</li> <li>No pre-made sketches allowed.</li> <li>Every 5-10 minutes, team members must exchange the painting.</li> <li>When the signal is given, the current painter must stop immediately and pass the artwork to the next teammate.</li> <li>Each participant must continue from what the previous teammate has done.</li> <li>Teams should work in a way that their combined styles create a complete and meaningful painting.</li> <li>Only the team members are allowed to participate in the creation of the design. No outside help or third-party assistance is permitted during the competition period.</li> <li>Contestants must maintain a clean workspace and ensure no materials are left in hazardous areas. All brushes, paints, and supplies should be stored properly after use.</li> <li>Any violation of the above rules may lead to disqualification. The organizers reserve the right to remove any team that fails to follow the guidelines.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool Distribution\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>1st Place:</strong> \\u20B92,500</li> <li><strong>2nd Place:</strong> \\u20B91,000</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person;\n  let current;\n  person = new Person_default({\n    props: { name: \"Julekhya\", phone: \"9392394687\" }\n  });\n  return {\n    c() {\n      create_component(person.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(person, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP33_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_10(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"\\u201CShake It Off\\u201D is a structural engineering competition designed to test the technical knowledge and practical design skills of participants. The primary aim is for participating teams to design and construct a model structure that is capable of withstanding a specified load while being subjected to simulated seismic tremors.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"The Challenge\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Testing & Criteria\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#problem\",\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#testing\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h10;\n  let t1;\n  let centersection;\n  let t2;\n  let h11;\n  let t4;\n  let p0;\n  let t8;\n  let p1;\n  let t13;\n  let p2;\n  let t16;\n  let p3;\n  let t20;\n  let p4;\n  let t24;\n  let p5;\n  let t28;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h10 = element(\"h1\");\n      h10.textContent = \"Shake It Off\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h11 = element(\"h1\");\n      h11.textContent = \"Event Details\";\n      t4 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Date:</strong> <strong>17th  of January, 3:00PM - 5:30PM</strong>`;\n      t8 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Resgistraion Fee:</strong> <strong>Rs 99</strong> per Head`;\n      t13 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Mode</strong>: Offline`;\n      t16 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Team Size:</strong> <strong>2 - 4 Members</strong>`;\n      t20 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Prize Worth:</strong> <strong>\\u20B910,000</strong>`;\n      t24 = space();\n      p5 = element(\"p\");\n      p5.innerHTML = `<strong>Type:</strong> <strong>On-site Construction &amp; Testing</strong>`;\n      t28 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h10, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h11, anchor);\n      insert(target, t4, anchor);\n      insert(target, p0, anchor);\n      insert(target, t8, anchor);\n      insert(target, p1, anchor);\n      insert(target, t13, anchor);\n      insert(target, p2, anchor);\n      insert(target, t16, anchor);\n      insert(target, p3, anchor);\n      insert(target, t20, anchor);\n      insert(target, p4, anchor);\n      insert(target, t24, anchor);\n      insert(target, p5, anchor);\n      insert(target, t28, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h10);\n        detach(t1);\n        detach(t2);\n        detach(h11);\n        detach(t4);\n        detach(p0);\n        detach(t8);\n        detach(p1);\n        detach(t13);\n        detach(p2);\n        detach(t16);\n        detach(p3);\n        detach(t20);\n        detach(p4);\n        detach(t24);\n        detach(p5);\n        detach(t28);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Problem Statement\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>All teams will be assigned a uniform task: to build a stable, free-standing structure using only the provided materials.</li> <li><strong>Materials:</strong> A standard kit (e.g., popsicle sticks, adhesives, straws, etc.) will be provided to each team.</li> <li><strong>Prohibitions:</strong> The use of any external, unapproved materials is strictly prohibited and will result in immediate disqualification.</li> <li><strong>Dimensional Constraints:</strong> The model must adhere to specific limitations regarding height and base area, which will be disclosed at the time of the event.</li> <li><strong>Time Limit:</strong> Teams will be given a fixed time limit to construct their models on-site.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h30;\n  let t1;\n  let ol;\n  let t13;\n  let h31;\n  let t15;\n  let ul;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Testing Procedure\";\n      t1 = space();\n      ol = element(\"ol\");\n      ol.innerHTML = `<li><strong>Inspection:</strong> Before testing, all models will be inspected by the judges to ensure they comply with the material and dimension constraints.</li> <li><strong>Loading:</strong> Structures will be required to support a certain loading placed at the top of the structure.</li> <li><strong>Shake Table Test:</strong> The structure, with the load applied, will be placed on a \\u201Cshaking table.\\u201D</li> <li><strong>Tremor Simulation:</strong> Vibrations and tremors will be simulated using driller instruments or a similar mechanism to create seismic activity. The intensity of the vibrations may be increased in stages.</li>`;\n      t13 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Judging & Winning Criteria\";\n      t15 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>Primary Criterion:</strong> The response of the model during shaking table testing is the only judging criterion.</li> <li><strong>Winning Condition:</strong> The model that lasts longest\\u2014remaining structurally sound and withstanding the tremors and loading for the maximum amount of time without collapsing\\u2014will be declared the winner.</li> <li><strong>Failure:</strong> A model is considered to have failed if it collapses or if the applied load falls off.</li> <li><strong>Finality:</strong> The decision of the event coordinators and judges will be final and binding.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ol, anchor);\n      insert(target, t13, anchor);\n      insert(target, h31, anchor);\n      insert(target, t15, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ol);\n        detach(t13);\n        detach(h31);\n        detach(t15);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>1st Prize:</strong> \\u20B95,000</li> <li><strong>2nd Prize:</strong> \\u20B93,000</li> <li><strong>3rd Prize:</strong> \\u20B92,000</li> <li><strong>Certificates:</strong> All participants will receive Certificates of Participation, and winners will receive Certificates of Achievement.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Divyanshu\", phone: \"7060716746\" }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Mradul Dwivedi\",\n      phone: \"91406 52930\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let p;\n  let t3;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"For any queries regarding the event, contact the organizers:\";\n      t3 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n        detach(t3);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"problem\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"testing\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP28_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let p2;\n  let t9;\n  let p3;\n  let t14;\n  let p4;\n  let t17;\n  let p5;\n  let t20;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"CodeWars\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"January 2026\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"CodeWars is a fast-paced competitive programming contest focused on algorithmic reasoning, precision, and problem-solving speed. Participants will tackle a carefully designed set of problems that reward strong fundamentals, logical insight, and the ability to translate ideas into correct and efficient code under time pressure.\";\n      t5 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Date:</strong> <strong>18th  of January, 2:00PM - 5:00PM</strong>`;\n      t9 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Resgistraion Fee:</strong> <strong>Rs 99</strong> per Head`;\n      t14 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Mode</strong>: Offline`;\n      t17 = space();\n      p5 = element(\"p\");\n      p5.innerHTML = `<strong>Prizes Worth:</strong> Rs  10000`;\n      t20 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      insert(target, p2, anchor);\n      insert(target, t9, anchor);\n      insert(target, p3, anchor);\n      insert(target, t14, anchor);\n      insert(target, p4, anchor);\n      insert(target, t17, anchor);\n      insert(target, p5, anchor);\n      insert(target, t20, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n        detach(p2);\n        detach(t9);\n        detach(p3);\n        detach(t14);\n        detach(p4);\n        detach(t17);\n        detach(p5);\n        detach(t20);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Individual participation only; open to all students.</li> <li>Allowed Programming Languages: C, C++, Java, and Python.</li> <li>All coding must be done during the official contest window.</li> <li>External communication, collaboration, or assistance is strictly prohibited.</li> <li>Use of AI tools or external code sources is not permitted.</li> <li>Internet access is restricted to the contest platform only.</li> <li>Each participant is allowed to use only one HackerRank account.</li> <li>Any form of plagiarism or unfair means will result in disqualification.</li> <li>The organizers&#39; decisions are final and binding.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let p0;\n  let t3;\n  let ul0;\n  let t13;\n  let p1;\n  let t15;\n  let ul1;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Structure\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Format</strong>`;\n      t3 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Duration: 3 Hours.</li> <li>Mode: Offline.</li> <li>The contest consists of 5 programming problems arranged in increasing order of difficulty.</li> <li>All problems are released at the start of the contest.</li> <li>Submissions are evaluated automatically using predefined test cases.</li>`;\n      t13 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Judging Criteria</strong>`;\n      t15 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Solutions are evaluated based on correctness against automated test cases.</li> <li>No partial scoring is applied; a solution must pass all test cases to receive the full score.</li> <li>Inefficient solutions may fail due to time or memory limits.</li> <li>Tie-Breaking: Rankings are decided by the sum of time of first correct submissions, measured from the start of the contest.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t13, anchor);\n      insert(target, p1, anchor);\n      insert(target, t15, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(ul0);\n        detach(t13);\n        detach(p1);\n        detach(t15);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: {\n      name: \"Nikhil Karlapudi\",\n      phone: \"78926 64547\"\n    }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Bathinwad Shivasai\",\n      phone: \"91009 46427\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizers\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CP19_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_9(ctx) {\n  let p0;\n  let t1;\n  let p1;\n  return {\n    c() {\n      p0 = element(\"p\");\n      p0.textContent = \"A head-to-head showdown where dancers battle it out, move for move, to claim the spotlight and the title of ultimate dance champion!\";\n      t1 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"Find your Groove. Make your Move!\";\n    },\n    m(target, anchor) {\n      insert(target, p0, anchor);\n      insert(target, t1, anchor);\n      insert(target, p1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p0);\n        detach(t1);\n        detach(p1);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h10;\n  let t1;\n  let centersection;\n  let t2;\n  let h11;\n  let t4;\n  let p0;\n  let t7;\n  let p1;\n  let t11;\n  let p2;\n  let t17;\n  let p3;\n  let t21;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h10 = element(\"h1\");\n      h10.textContent = \"Syncfix: Dance Battle\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h11 = element(\"h1\");\n      h11.textContent = \"Registration\";\n      t4 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Registration Fee:</strong> Rs. 79`;\n      t7 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Prizes Worth:</strong> Rs. <strong>7.5k</strong>`;\n      t11 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Registration Period:</strong> <strong>6th January</strong> - <strong>14th January</strong>`;\n      t17 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Event Date:</strong> <strong>18th January</strong>`;\n      t21 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h10, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h11, anchor);\n      insert(target, t4, anchor);\n      insert(target, p0, anchor);\n      insert(target, t7, anchor);\n      insert(target, p1, anchor);\n      insert(target, t11, anchor);\n      insert(target, p2, anchor);\n      insert(target, t17, anchor);\n      insert(target, p3, anchor);\n      insert(target, t21, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h10);\n        detach(t1);\n        detach(t2);\n        detach(h11);\n        detach(t4);\n        detach(p0);\n        detach(t7);\n        detach(p1);\n        detach(t11);\n        detach(p2);\n        detach(t17);\n        detach(p3);\n        detach(t21);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"General Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>All participants must report at the venue 30 minutes before the event time and must be at the venue throughout the event.</li> <li>Inflammable objects, water, risking stunts and heavy props are not permitted.</li> <li>Decision by the judge will be final and any kind of misbehavior will result in disqualification.</li> <li>Spot registrations will be available prior to the start of the event.</li> <li>Maintain venue decorum and cooperate with event staff for a smooth experience.</li> <li>Spotlights can be provided if requested in advance through the registration link.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Event Structure (Three Rounds)\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>Round 1:</strong> All participants will dance to varied and unpredictable beats, showcasing their ability to sync with the rhythm. The best performers advance.</li> <li><strong>Round 2:</strong> Selected 12 participants paired into 6 groups for 1 vs 1 battles. Two rounds with different songs (30s and 20s) for a total of 50 seconds. Top 6 advance.</li> <li><strong>Round 3:</strong> Top 6 assigned numbers for random 1 vs 1 battles. Winners emerge as the top three performers.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Judging Criteria\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Execution: 20%</li> <li>Creativity and Originality: 20%</li> <li>Energy and Dynamic: 20%</li> <li>Performance of various style: 15%</li> <li>Sync to the beat: 10%</li> <li>Spontaneity: 10%</li> <li>Crowd pulling: 5%</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: {\n      name: \"Bavanamrutha\",\n      phone: \"9985049999\"\n    }\n  });\n  person1 = new Person_default({\n    props: { name: \"Siddhardh\", phone: \"9145335333\" }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"judging\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CP35_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_10(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Format\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rules\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#format\",\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let h1;\n  let t1;\n  let h20;\n  let t3;\n  let p0;\n  let t5;\n  let h21;\n  let t7;\n  let p1;\n  let t11;\n  let p2;\n  let t15;\n  let p3;\n  let t19;\n  let p4;\n  let t23;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Vlog Wars\";\n      t1 = space();\n      h20 = element(\"h2\");\n      h20.textContent = \"Offline mini-Vlog Making\";\n      t3 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"Get out your cameras and document the energy of the fest! In this event, you are the storyteller. Your mission is to capture the best moments of Petrichor - from the electrifying performances to the backstage chaos and crowd reactions. Create a 1-3 minute mini-vlog that makes everyone wish they were there.\";\n      t5 = space();\n      h21 = element(\"h2\");\n      h21.textContent = \"Event Details\";\n      t7 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Registration Fee:</strong> <strong>\\u20B979</strong>`;\n      t11 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Total Prize Pool:</strong> <strong>Rs. 3,000</strong>`;\n      t15 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Shoot Date:</strong> <strong>Jan 17-18 (During Fest)</strong>`;\n      t19 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Submission:</strong> <strong>Jan 21 (11:59PM)</strong>`;\n      t23 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, h20, anchor);\n      insert(target, t3, anchor);\n      insert(target, p0, anchor);\n      insert(target, t5, anchor);\n      insert(target, h21, anchor);\n      insert(target, t7, anchor);\n      insert(target, p1, anchor);\n      insert(target, t11, anchor);\n      insert(target, p2, anchor);\n      insert(target, t15, anchor);\n      insert(target, p3, anchor);\n      insert(target, t19, anchor);\n      insert(target, p4, anchor);\n      insert(target, t23, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(h20);\n        detach(t3);\n        detach(p0);\n        detach(t5);\n        detach(h21);\n        detach(t7);\n        detach(p1);\n        detach(t11);\n        detach(p2);\n        detach(t15);\n        detach(p3);\n        detach(t19);\n        detach(p4);\n        detach(t23);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Format\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Duration: 1-3 minutes.</li> <li>Orientation: Vertical (9:16) preferred.</li> <li>Must cover Petrichor\\u201926 - IIT Palakkad\\u2019s Annual Techno-Cultural Fest only.</li> <li>Cover different events (e.g., Band, Dance, Food).</li> <li>Add Voiceover/Commentary/Captions.</li> <li>All languages are allowed for commentary/voiceover (English subtitles would be appreciated).</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Footage must be shot on-ground at the fest (Jan 17-18).</li> <li>Ask before filming close-ups, please respect other people\\u2019s space.</li> <li>Vulgarity and/or obscenity will lead to disqualification.</li> <li>Entries will be featured later on our social media page.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Judging\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Coverage (25): Variety of events shown.</li> <li>Story (30): Narrative flow &amp; commentary.</li> <li>Edit (25): Quality, cuts, audio levels.</li> <li>Fun Factor (20): Is it engaging?</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool Distribution\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>1st Place:</strong> \\u20B92500</li> <li><strong>2nd Place:</strong> \\u20B91500</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: {\n      name: \"Ekansh Aditya\",\n      phone: \"9301113096\"\n    }\n  });\n  person1 = new Person_default({\n    props: { name: \"Ram Praveen\", phone: \"7989530128\" }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let section3;\n  let t4;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"format\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"judging\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section3 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(section3.$$.fragment);\n      t4 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(section3, target, anchor);\n      insert(target, t4, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const section3_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section3_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section3.$set(section3_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(section3.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(section3.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n        detach(t4);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(section3, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CF26_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let h3;\n  let t3;\n  let p0;\n  let t5;\n  let h2;\n  let t7;\n  let p1;\n  let t10;\n  let p2;\n  let t13;\n  let p3;\n  let t17;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Two of a Rhythm\";\n      t1 = space();\n      h3 = element(\"h3\");\n      h3.textContent = \"Duet Event\";\n      t3 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"A lively event where two musicians team up for an exciting and dynamic performance. Show us your synergy!\";\n      t5 = space();\n      h2 = element(\"h2\");\n      h2.textContent = \"Events Details\";\n      t7 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Registration fee:</strong> Rs. 149`;\n      t10 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Prizes Worth:</strong> 7.5k`;\n      t13 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Submission Link for Round 1:</strong> <a href=\"https://docs.google.com/forms/d/e/1FAIpQLSeesH5hNqklajpzxUW_7x05d9Me5-bTyJXJwmTTFGNqOOXAfw/viewform?usp=header\" target=\"_blank\">Click Here</a>`;\n      t17 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, h3, anchor);\n      insert(target, t3, anchor);\n      insert(target, p0, anchor);\n      insert(target, t5, anchor);\n      insert(target, h2, anchor);\n      insert(target, t7, anchor);\n      insert(target, p1, anchor);\n      insert(target, t10, anchor);\n      insert(target, p2, anchor);\n      insert(target, t13, anchor);\n      insert(target, p3, anchor);\n      insert(target, t17, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(h3);\n        detach(t3);\n        detach(p0);\n        detach(t5);\n        detach(h2);\n        detach(t7);\n        detach(p1);\n        detach(t10);\n        detach(p2);\n        detach(t13);\n        detach(p3);\n        detach(t17);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Each duo must contain at least one instrumentalist.</li> <li>A person can play for only one duo.</li> <li>Extra points will be awarded for original compositions.</li> <li>Acapella is not allowed.</li> <li>Pre-recorded tracks are strictly prohibited (immediate disqualification).</li> <li>Obscenity on stage is strictly prohibited.</li> <li>Exceeding the time limit will lead to negative points.</li> <li>All genres are allowed.</li> <li>Judges&#39; decisions are final and binding.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let p0;\n  let t4;\n  let ul0;\n  let t12;\n  let p1;\n  let t15;\n  let ul1;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Structure\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Round 1 (Online Submissions):</strong> Pairs are required to post an audiovisual recording (2\\u20134 mins) of their performance via the Google Form on the Petrichor Website.`;\n      t4 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Usage of pre-recorded tracks is strictly prohibited.</li> <li>Both members must be clearly visible.</li> <li>Audio must be clear for evaluation.</li> <li>Video length: 2\\u20134 minutes.</li>`;\n      t12 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Round 2 (Grand Finale):</strong> Selected entries will perform live on stage in Petrichor.`;\n      t15 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Time limit: 10 minutes (including setup and soundchecks).</li> <li>Contestants should bring their own instruments (only a drum kit will be provided).</li> <li>All music must be played live on stage; live looping is not allowed.</li> <li>The pair performing offline must be the same as in the uploaded video.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t4, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t12, anchor);\n      insert(target, p1, anchor);\n      insert(target, t15, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p0);\n        detach(t4);\n        detach(ul0);\n        detach(t12);\n        detach(p1);\n        detach(t15);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Yazeed\", phone: \"8593930099\" }\n  });\n  person1 = new Person_default({\n    props: { name: \"Prachurjya\", phone: \"9435301264\" }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizers\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "IF01_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance3, create_fragment4, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance3 ? instance3(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment4 ? create_fragment4($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./CenterSection.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment2(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0 }, add_css2);\n  }\n};\nvar CenterSection_default = Component2;\n\n// components:./markdown.mdx\nfunction create_default_slot_1(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Step beyond reality and into the game! \\u{1F576}\\uFE0F Experience cutting-edge AR/VR technology that drops you into immersive virtual worlds filled with action, adventure, and interactive challenges. Feel every move, every shot, and every twist as the line between real and virtual disappears. Get ready for a mind-blowing gaming experience like never before. \\u{1F680}\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let centersection;\n  let t2;\n  let h2;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"AR / VR Games\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h2 = element(\"h2\");\n      h2.textContent = \"Venue: Agora Annex\";\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h2, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(t2);\n        detach(h2);\n      }\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nfunction create_fragment3(ctx) {\n  let box;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(box, detaching);\n    }\n  };\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment3, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component3;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP22_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_11(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"Welcome to ROBO WAR - the ultimate battle of power, engineering, and strategy. This competition challenges teams to design, build, and control a robot capable of dominating a head-to-head arena fight - using pure skill, torque, control, and smart engineering. The objective is simple: push your opponent out of the designated battle zone - just like a robotic sumo.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_10(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Description\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Full Rules\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#description\",\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let h10;\n  let t1;\n  let centersection;\n  let t2;\n  let h11;\n  let t4;\n  let p0;\n  let t8;\n  let p1;\n  let t13;\n  let p2;\n  let t16;\n  let p3;\n  let t20;\n  let p4;\n  let t24;\n  let p5;\n  let t28;\n  let p6;\n  let t32;\n  let p7;\n  let t36;\n  let p8;\n  let t40;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_11] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h10 = element(\"h1\");\n      h10.textContent = \"ROBO WARS\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h11 = element(\"h1\");\n      h11.textContent = \"Event Details\";\n      t4 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Date:</strong> <strong>17th  of January, 2:00PM - 6:00PM</strong>`;\n      t8 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Resgistraion Fee:</strong> <strong>Rs 99</strong> per Head`;\n      t13 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Mode</strong>: Offline`;\n      t16 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Weight Category:</strong> <strong>25 KG</strong>`;\n      t20 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Prizes Worth:</strong> <strong>Rs 35000</strong>`;\n      t24 = space();\n      p5 = element(\"p\");\n      p5.innerHTML = `<strong>1st :</strong> <strong>Rs 16500</strong>`;\n      t28 = space();\n      p6 = element(\"p\");\n      p6.innerHTML = `<strong>2nd :</strong> <strong>Rs 11500</strong>`;\n      t32 = space();\n      p7 = element(\"p\");\n      p7.innerHTML = `<strong>3rd :</strong> <strong>Rs 7000</strong>`;\n      t36 = space();\n      p8 = element(\"p\");\n      p8.innerHTML = `<strong>Arena Size:</strong> <strong>12 feet x 16 feet</strong>`;\n      t40 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h10, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h11, anchor);\n      insert(target, t4, anchor);\n      insert(target, p0, anchor);\n      insert(target, t8, anchor);\n      insert(target, p1, anchor);\n      insert(target, t13, anchor);\n      insert(target, p2, anchor);\n      insert(target, t16, anchor);\n      insert(target, p3, anchor);\n      insert(target, t20, anchor);\n      insert(target, p4, anchor);\n      insert(target, t24, anchor);\n      insert(target, p5, anchor);\n      insert(target, t28, anchor);\n      insert(target, p6, anchor);\n      insert(target, t32, anchor);\n      insert(target, p7, anchor);\n      insert(target, t36, anchor);\n      insert(target, p8, anchor);\n      insert(target, t40, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h10);\n        detach(t1);\n        detach(t2);\n        detach(h11);\n        detach(t4);\n        detach(p0);\n        detach(t8);\n        detach(p1);\n        detach(t13);\n        detach(p2);\n        detach(t16);\n        detach(p3);\n        detach(t20);\n        detach(p4);\n        detach(t24);\n        detach(p5);\n        detach(t28);\n        detach(p6);\n        detach(t32);\n        detach(p7);\n        detach(t36);\n        detach(p8);\n        detach(t40);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Introduction & Description\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>This event is not just a fight; it\\u2019s a test of: Mechanical design, Electronics &amp; control systems, Driving reflexes, and Strategic thinking under pressure.</li> <li><strong>Problem Statement:</strong> Design and build a combat robot capable of competing in a one-on-one battle against other robots in a controlled arena.</li> <li>Your robot must demonstrate durability, agility, and effective combat mechanisms to outperform opponents while adhering to the event\\u2019s rules and safety standards.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Game Structure\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Two robots will face off in three round matches where each round will be maximum of duration 5 minutes and a 2-minute break in between the rounds for repairs if needed.</li> <li>The winners of the qualifier matches will be declared as per the points they would achieve in the three rounds.</li> <li>Arena will be divided in different parts and participants have to fight in that area.</li> <li>One who pushed outside of the designated area will be eliminated for that round.</li> <li><strong>Note:</strong> If any of the team\\u2019s ROBO or its related components not supporting or need repairing (takes more than 2 min) after starting of matches then points will be deducted from their account.</li> <li><strong>Special Case:</strong> If there will be any severe damage to robot during match then the interval time will be given up to 5 mins.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h30;\n  let t1;\n  let ul0;\n  let t10;\n  let h31;\n  let t12;\n  let ul1;\n  let t20;\n  let h32;\n  let t22;\n  let ul2;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Robot Specifications (25 KG Weight Category)\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li><strong>Dimensions:</strong> The dimensions of the robot should not exceed 75 cm x 75 cm x 75 cm at any point during the match.</li> <li><strong>Weight:</strong> The weight of the robot should be less than 25 kg (55.116 lbs). Note that the weight of adapters and the remote controller will not be included in these constraints.</li> <li><strong>Power Source:</strong> The power source of the robot cannot exceed 40V.</li>`;\n      t10 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Mobility\";\n      t12 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Methods of mobility may include rolling (wheels, tracks, or the whole robot), walking (linear actuated legs with no rolling or cam operated motion), shuffling (rotational cam operated legs).</li> <li>Jumping and hopping are not allowed.</li> <li>Flying (using aerofoil, helium balloons, ornithopters, etc.) is not allowed.</li> <li>Any other method of mobility that leads the robot to lose contact with the ground is not allowed.</li>`;\n      t20 = space();\n      h32 = element(\"h3\");\n      h32.textContent = \"Control Specifications\";\n      t22 = space();\n      ul2 = element(\"ul\");\n      ul2.innerHTML = `<li>Both wired and wireless remote controls are allowed in the event.</li> <li>All wires coming out of the robot should be bundled as a single unit.</li> <li>The wires should be properly protected and insulated.</li> <li>If the machine is controlled wirelessly, the machine must have at least a four-frequency remote control circuit or two dual control circuits, which may be interchanged before the start of the match to avoid frequency interference with the opposing team.</li> <li>In the case of any interference in the wireless systems, it will not be considered for a rematch or affect the results.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t10, anchor);\n      insert(target, h31, anchor);\n      insert(target, t12, anchor);\n      insert(target, ul1, anchor);\n      insert(target, t20, anchor);\n      insert(target, h32, anchor);\n      insert(target, t22, anchor);\n      insert(target, ul2, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ul0);\n        detach(t10);\n        detach(h31);\n        detach(t12);\n        detach(ul1);\n        detach(t20);\n        detach(h32);\n        detach(t22);\n        detach(ul2);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h30;\n  let t1;\n  let ul0;\n  let t5;\n  let h31;\n  let t7;\n  let ul1;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Weapon Systems\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Robots can have any kind of flippers, wedges, lifting devices, etc. as weapons.</li> <li>Only the weapons mentioned above are allowed, and inclusion of any other weapon is not allowed.</li>`;\n      t5 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Penalties\";\n      t7 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>If the robot intentionally continues pushing after a clear out-of-bound moment: Warning for first offense; disqualification for second.</li> <li>Any controller, team member, or technician who steps into the arena area without permission will lose the round.</li> <li>Intentionally avoiding combat by staying stationary, circling endlessly, or refusing engagement: For first time - Warning, for Second time - Round loss.</li> <li>Abusive behavior towards referees, opponents, or volunteers: For first time - Team warning; for second time - penalty.</li> <li>Severe cases: Event-wide disqualification.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t5, anchor);\n      insert(target, h31, anchor);\n      insert(target, t7, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ul0);\n        detach(t5);\n        detach(h31);\n        detach(t7);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"G Rahul\", phone: \"8977385773\" }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Krishna Kumar Roy\",\n      phone: \"8789703392\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let section3;\n  let t4;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"description\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section3 = new Section_default({\n    props: {\n      name: \"weapons-penalties\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(section3.$$.fragment);\n      t4 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(section3, target, anchor);\n      insert(target, t4, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const section3_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section3_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section3.$set(section3_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(section3.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(section3.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n        detach(t4);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(section3, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "IF02_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance3, create_fragment4, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance3 ? instance3(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment4 ? create_fragment4($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./CenterSection.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment2(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0 }, add_css2);\n  }\n};\nvar CenterSection_default = Component2;\n\n// components:./markdown.mdx\nfunction create_default_slot_1(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"Test your focus, steady your hands, and aim for the bullseye! \\u{1F3AF} Experience the thrill of real archery as every shot challenges your precision, patience, and control. Feel the tension build as you pull the string and release\\u2014only the sharpest aim wins. Are you ready to prove your accuracy? \\u{1F3F9}\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let centersection;\n  let t2;\n  let h2;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Archery\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h2 = element(\"h2\");\n      h2.textContent = \"Venue: Football Ground\";\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h2, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(t2);\n        detach(h2);\n      }\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nfunction create_fragment3(ctx) {\n  let box;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(box, detaching);\n    }\n  };\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment3, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component3;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "IF03_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance3, create_fragment4, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance3 ? instance3(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment4 ? create_fragment4($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./CenterSection.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment2(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0 }, add_css2);\n  }\n};\nvar CenterSection_default = Component2;\n\n// components:./markdown.mdx\nfunction create_default_slot_1(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"Start your engines and hit full throttle! \\u{1F6DE} Dive into high-speed racing with realistic controls, intense tracks, and adrenaline-packed competition. Feel every turn, drift, and overtake as you race against time and rivals. Buckle up and race your way to victory! \\u{1F3CE}\\uFE0F\\u{1F525}\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let centersection;\n  let t2;\n  let h2;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Car Console\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h2 = element(\"h2\");\n      h2.textContent = \"Venue: Agora Annex\";\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h2, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(t2);\n        detach(h2);\n      }\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nfunction create_fragment3(ctx) {\n  let box;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(box, detaching);\n    }\n  };\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment3, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component3;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP23_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_10(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"Reverse Engineering is a high-stakes technical challenge that tests your analytical skills and circuit design mastery. Teams are tasked with deciphering the secrets of a \\u201CBlackbox\\u201D circuit. By analyzing the output for various inputs, participants must deduce the internal logic and recreate the exact circuit using a set of components. It is a pure test of logic, deduction, and engineering precision.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"The Challenge\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rules & Evaluation\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#challenge\",\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h10;\n  let t1;\n  let centersection;\n  let t2;\n  let h11;\n  let t4;\n  let p0;\n  let t8;\n  let p1;\n  let t13;\n  let p2;\n  let t16;\n  let p3;\n  let t20;\n  let p4;\n  let t24;\n  let p5;\n  let t28;\n  let p6;\n  let t32;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h10 = element(\"h1\");\n      h10.textContent = \"Reverse Engineering\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h11 = element(\"h1\");\n      h11.textContent = \"Event Details\";\n      t4 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Date:</strong> <strong>17th  of January, 9:00AM - 12:30PM</strong>`;\n      t8 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Resgistraion Fee:</strong> <strong>Rs 99</strong> per Head`;\n      t13 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Mode</strong>: Offline`;\n      t16 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Location:</strong> <strong>Nila Electronics Lab</strong>`;\n      t20 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Duration:</strong> <strong>4 hours</strong>`;\n      t24 = space();\n      p5 = element(\"p\");\n      p5.innerHTML = `<strong>Team Size:</strong> <strong>Maximum 3 participants per team</strong>`;\n      t28 = space();\n      p6 = element(\"p\");\n      p6.innerHTML = `<strong>Prize Worth:</strong> <strong>\\u20B915,000</strong>`;\n      t32 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h10, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h11, anchor);\n      insert(target, t4, anchor);\n      insert(target, p0, anchor);\n      insert(target, t8, anchor);\n      insert(target, p1, anchor);\n      insert(target, t13, anchor);\n      insert(target, p2, anchor);\n      insert(target, t16, anchor);\n      insert(target, p3, anchor);\n      insert(target, t20, anchor);\n      insert(target, p4, anchor);\n      insert(target, t24, anchor);\n      insert(target, p5, anchor);\n      insert(target, t28, anchor);\n      insert(target, p6, anchor);\n      insert(target, t32, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h10);\n        detach(t1);\n        detach(t2);\n        detach(h11);\n        detach(t4);\n        detach(p0);\n        detach(t8);\n        detach(p1);\n        detach(t13);\n        detach(p2);\n        detach(t16);\n        detach(p3);\n        detach(t20);\n        detach(p4);\n        detach(t24);\n        detach(p5);\n        detach(t28);\n        detach(p6);\n        detach(t32);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let ul0;\n  let t17;\n  let p2;\n  let t19;\n  let ul1;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"The Challenge\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"The competition is divided into two intense rounds:\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Round 1: The Deduction</strong>`;\n      t5 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li><strong>Max Assembling Time:</strong> 2 Hours.</li> <li><strong>The Components:</strong> Identical component sets will be provided to all teams. These will only be revealed after an initial observation period of 15 minutes.</li> <li><strong>Prototyping:</strong> Participants are encouraged to construct a circuit schematic in software like SPICE, Logisim, etc. for prototyping before physical assembly.</li> <li><strong>Qualification:</strong> The Top 5 teams from this round will qualify for the second round.</li>`;\n      t17 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Round 2: The Auction</strong>`;\n      t19 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li><strong>Max Assembling Time:</strong> 1.5 Hours.</li> <li><strong>The Observation:</strong> All teams begin with the same observation time of 15 minutes.</li> <li><strong>The Auction:</strong> Different sets of components, with varying levels of utility and quality (revealed prior to auction), will be auctioned off.</li> <li><strong>The Cost:</strong> The amount your team bids and pays for components will be directly deducted from your total score.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t17, anchor);\n      insert(target, p2, anchor);\n      insert(target, t19, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n        detach(ul0);\n        detach(t17);\n        detach(p2);\n        detach(t19);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h30;\n  let t1;\n  let ul0;\n  let t19;\n  let h31;\n  let t21;\n  let ul1;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Eligibility & Rules\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li><strong>Tools:</strong> Teams are allowed (and encouraged) to use SPICE software or similar to construct circuit schematics for prototyping.</li> <li><strong>Completion:</strong> If a team is unable to complete the physical circuit within the time limit, their digital prototyping will be evaluated for partial credit.</li> <li><strong>Extra Observation:</strong> Teams may request additional observation periods. Each 5-minute block enabled will cost 5 points (in Round 1) or 10 points (in Round 2) from your final score out of 100.</li> <li><strong>Hardware:</strong> All necessary physical components will be provided (or auctioned) on-site.</li> <li><strong>Requirements:</strong> Participants are expected to bring their own laptops with their required softwares.</li> <li><strong>Decisions:</strong> The organiser\\u2019s decisions are final and should not be questioned.</li>`;\n      t19 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Evaluation Criteria\";\n      t21 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Accuracy of Circuit: <strong>70%</strong></li> <li>Component efficiency: <strong>20%</strong></li> <li>Assembling Period Duration: <strong>10%</strong></li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t19, anchor);\n      insert(target, h31, anchor);\n      insert(target, t21, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ul0);\n        detach(t19);\n        detach(h31);\n        detach(t21);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>1st Position:</strong> \\u20B97,000</li> <li><strong>2nd Position:</strong> \\u20B95,000</li> <li><strong>3rd Position:</strong> \\u20B93,000</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Athira S J\", phone: \"9446665640\" }\n  });\n  person1 = new Person_default({\n    props: { name: \"Akshat\", phone: \"8129831532\" }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let p;\n  let t3;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"For any queries, you can contact:\";\n      t3 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n        detach(t3);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"challenge\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CF20_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let h3;\n  let t3;\n  let p0;\n  let t5;\n  let h2;\n  let t7;\n  let p1;\n  let t10;\n  let p2;\n  let t13;\n  let p3;\n  let t17;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Breaking Bands\";\n      t1 = space();\n      h3 = element(\"h3\");\n      h3.textContent = \"Offline Band Competition\";\n      t3 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"Public event designed to identify and award outstanding music ensembles, instrumentalists, soloists, and composers. Platform for bands to break into the music scene.\";\n      t5 = space();\n      h2 = element(\"h2\");\n      h2.textContent = \"Event Details\";\n      t7 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Registration fee:</strong> Rs. 179`;\n      t10 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Prizes Worth:</strong> 20k`;\n      t13 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Submission Link fo Round 1:</strong> <a href=\"https://docs.google.com/forms/d/e/1FAIpQLSd-zkjl7QWwllBe597Oq1m9PkJP-1K1DRcYXKSGB8BGPTpWnA/viewform?usp=header\" target=\"_blank\">Click here</a>`;\n      t17 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, h3, anchor);\n      insert(target, t3, anchor);\n      insert(target, p0, anchor);\n      insert(target, t5, anchor);\n      insert(target, h2, anchor);\n      insert(target, t7, anchor);\n      insert(target, p1, anchor);\n      insert(target, t10, anchor);\n      insert(target, p2, anchor);\n      insert(target, t13, anchor);\n      insert(target, p3, anchor);\n      insert(target, t17, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(h3);\n        detach(t3);\n        detach(p0);\n        detach(t5);\n        detach(h2);\n        detach(t7);\n        detach(p1);\n        detach(t10);\n        detach(p2);\n        detach(t13);\n        detach(p3);\n        detach(t17);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Band size should be between 4 and 15 members, although a maximum of 10 members are allowed on stage at a time.</li> <li>A person can play for only one single band.</li> <li>Extra points will be awarded for original compositions.</li> <li>All instruments must be brought by the band (only a drum kit will be provided).</li> <li>The band must have at least two instrumentalists present.</li> <li>Acapella is not allowed.</li> <li>Pre-recorded sounds are strictly prohibited (immediate disqualification).</li> <li>Obscenity on stage is strictly prohibited.</li> <li>Exceeding the time limit will lead to negative points.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let p0;\n  let t4;\n  let ul0;\n  let t12;\n  let p1;\n  let t15;\n  let ul1;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Structure\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Round 1 (Online Submissions):</strong> Teams are required to post an audiovisual recording (3\\u20135 mins) of their performance via the Google Form on the Petrichor Website.`;\n      t4 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>All members of the band should be clearly visible in the uploaded video.</li> <li>The uploaded video should be within a time limit of 3 to 5 minutes.</li> <li>Audio in the uploaded file should be clear for the judges to evaluate.</li> <li>Editing software (Audacity, Reaper, etc.) can be used.</li>`;\n      t12 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Round 2 (Grand Finale):</strong> Selected entries will perform live on stage in Petrichor.`;\n      t15 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Time limit: 15 minutes (including setup and soundchecks).</li> <li>All music must be played live on stage; live looping is not allowed.</li> <li>The members performing offline must be the same as in the uploaded video.</li> <li>Judges&#39; decisions are final and binding.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t4, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t12, anchor);\n      insert(target, p1, anchor);\n      insert(target, t15, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p0);\n        detach(t4);\n        detach(ul0);\n        detach(t12);\n        detach(p1);\n        detach(t15);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Yazeed\", phone: \"8593930099\" }\n  });\n  person1 = new Person_default({\n    props: { name: \"Prachurjya\", phone: \"9435301264\" }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizers\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "IF04_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance3, create_fragment4, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance3 ? instance3(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment4 ? create_fragment4($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./CenterSection.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment2(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0 }, add_css2);\n  }\n};\nvar CenterSection_default = Component2;\n\n// components:./markdown.mdx\nfunction create_default_slot_1(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"Next-gen gaming is here! \\u{1F3AE} Experience ultra-fast load times, buttery-smooth gameplay, and breathtaking visuals that pull you straight into the action. From intense multiplayer battles to immersive story-driven adventures, feel every moment come alive with powerful sound and responsive controls. Compete with friends, take on epic challenges, and level up your skills in a gaming experience that\\u2019s faster, sharper, and more thrilling than ever. \\u26A1\\u{1F525}\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let centersection;\n  let t2;\n  let h2;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"PS5 Games\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h2 = element(\"h2\");\n      h2.textContent = \"Venue: Agora Annex\";\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h2, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(t2);\n        detach(h2);\n      }\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nfunction create_fragment3(ctx) {\n  let box;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(box, detaching);\n    }\n  };\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment3, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component3;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CF32_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_10(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"Showcase your storytelling skills in this creative writing competition. Participants must craft a story based on provided prompts while adhering to specific guidelines on length, language, and originality.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rules & Guidelines\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Judging Criteria\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#judging\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h1;\n  let t1;\n  let centersection;\n  let t2;\n  let h2;\n  let t4;\n  let p0;\n  let t7;\n  let p1;\n  let t10;\n  let p2;\n  let t13;\n  let p3;\n  let t17;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"KATHA\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h2 = element(\"h2\");\n      h2.textContent = \"Event Details\";\n      t4 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Word Limit:</strong> 2000 words`;\n      t7 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Language:</strong> English or Hindi`;\n      t10 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Submission:</strong> Single entry per participant`;\n      t13 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Submission Link:</strong> <a href=\"https://forms.gle/5P2xj5UMqiLRTRCj6\" target=\"_blank\">Click Here</a>`;\n      t17 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h2, anchor);\n      insert(target, t4, anchor);\n      insert(target, p0, anchor);\n      insert(target, t7, anchor);\n      insert(target, p1, anchor);\n      insert(target, t10, anchor);\n      insert(target, p2, anchor);\n      insert(target, t13, anchor);\n      insert(target, p3, anchor);\n      insert(target, t17, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(t2);\n        detach(h2);\n        detach(t4);\n        detach(p0);\n        detach(t7);\n        detach(p1);\n        detach(t10);\n        detach(p2);\n        detach(t13);\n        detach(p3);\n        detach(t17);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let ol;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prompts\";\n      t1 = space();\n      ol = element(\"ol\");\n      ol.innerHTML = `<li>I could direct my life but the script betrayed me</li> <li>The Memory box - You find a box of memories that arent yours - but they feel like they should be</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ol, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ol);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Competition Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>The story should not exceed the word limit of 2000 words and must be based on the prompts provided.</li> <li>Exceeding the word limit will attract a penalty of -5 for every extra 50 words used.</li> <li>The entry must be in English or Hindi with an appropriate title.</li> <li>The use of language should be careful. No part of society or individual should be offended.</li> <li>Only one submission is allowed per participant.</li> <li>The entry must be the original work of the participant and must not have been published elsewhere.</li> <li>All entries must be sent in the format: Name of Story_Name of participant.</li> <li>Illustrations such as graphs and sketches are not allowed.</li> <li>Only stories submitted before the deadline will be considered for results.</li> <li>Plagiarism and the use of explicit content will lead to immediate disqualification.</li> <li>The decisions made by the judges are final.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Judging Criteria\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Creativity: 35</li> <li>Originality: 35</li> <li>Relevance of Theme: 30</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person;\n  let current;\n  person = new Person_default({\n    props: { name: \"Bhoomika\", phone: \"9633054731\" }\n  });\n  return {\n    c() {\n      create_component(person.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(person, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let p;\n  let t3;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"For any queries, contact the coordinators:\";\n      t3 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n        detach(t3);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"prompts\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"judging\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP24_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_9(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"A unique competitive programming event where the challenge begins before you even start coding. Participants are presented with input-output pairs only\\u2014no problem statement is provided. You must reverse-engineer the underlying logic, deduce the requirements, and write a program that produces correct results for hidden test cases. This is a true test of analytical thinking, pattern recognition, and coding proficiency.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Event Structure\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rules & Judging\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#structure\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h10;\n  let t1;\n  let centersection;\n  let t2;\n  let h11;\n  let t4;\n  let p0;\n  let t9;\n  let p1;\n  let t13;\n  let p2;\n  let t16;\n  let p3;\n  let t19;\n  let p4;\n  let t22;\n  let p5;\n  let t25;\n  let p6;\n  let t28;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h10 = element(\"h1\");\n      h10.textContent = \"SOURCE CODE\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h11 = element(\"h1\");\n      h11.textContent = \"Event Details\";\n      t4 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Resgistraion Fee:</strong> <strong>Rs 99</strong> per Head`;\n      t9 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Date:</strong> <strong>17th  of January, 9:00AM -12:00PM</strong>`;\n      t13 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Mode</strong>: Offline`;\n      t16 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Participation:</strong> Individual`;\n      t19 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Opportunity:</strong> Open to all`;\n      t22 = space();\n      p5 = element(\"p\");\n      p5.innerHTML = `<strong>Prize Worth:</strong> Rs 10000`;\n      t25 = space();\n      p6 = element(\"p\");\n      p6.innerHTML = `<strong>Team Size:</strong> 1 (Individual only)`;\n      t28 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h10, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h11, anchor);\n      insert(target, t4, anchor);\n      insert(target, p0, anchor);\n      insert(target, t9, anchor);\n      insert(target, p1, anchor);\n      insert(target, t13, anchor);\n      insert(target, p2, anchor);\n      insert(target, t16, anchor);\n      insert(target, p3, anchor);\n      insert(target, t19, anchor);\n      insert(target, p4, anchor);\n      insert(target, t22, anchor);\n      insert(target, p5, anchor);\n      insert(target, t25, anchor);\n      insert(target, p6, anchor);\n      insert(target, t28, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h10);\n        detach(t1);\n        detach(t2);\n        detach(h11);\n        detach(t4);\n        detach(p0);\n        detach(t9);\n        detach(p1);\n        detach(t13);\n        detach(p2);\n        detach(t16);\n        detach(p3);\n        detach(t19);\n        detach(p4);\n        detach(t22);\n        detach(p5);\n        detach(t25);\n        detach(p6);\n        detach(t28);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let p0;\n  let t3;\n  let ul0;\n  let t13;\n  let p1;\n  let t15;\n  let ul1;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Event Structure\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Qualifier Round</strong>`;\n      t3 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Duration: 1 Hour.</li> <li>Format: 40 MCQ-style questions.</li> <li>Marking Scheme: +4 for each correct answer and -1 for each incorrect answer.</li> <li>Qualifying Condition: Contestants must rank in the top 50% of scorers, or the top 30 scorers if there are more than 60 participants.</li> <li>Content: Questions based on basic programming and logic; all code snippets in the paper will be written in Python.</li>`;\n      t13 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Final Round</strong>`;\n      t15 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Duration: 2 Hours.</li> <li>Format: Web-based evaluation on a competitive programming platform.</li> <li>Goal: Deduce the exact problem logic from sample input-output pairs and produce correct, efficient code for all hidden test cases.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t13, anchor);\n      insert(target, p1, anchor);\n      insert(target, t15, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(ul0);\n        detach(t13);\n        detach(p1);\n        detach(t15);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h30;\n  let t1;\n  let ul0;\n  let t13;\n  let h31;\n  let t15;\n  let ul1;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Eligibility and Rules\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Participation is limited to individual contestants only.</li> <li>Participants may use any programming language supported by the contest platform. In the event of an absolute tiebreak, the original Python code performance will be used as a reference.</li> <li>All submitted code must be original; any form of plagiarism will result in immediate disqualification.</li> <li>Output must match the expected format exactly, including spacing and capitalization.</li> <li>Participants must not communicate or discuss problems with others during the event.</li> <li>All problems must be solved entirely within the official event duration.</li>`;\n      t13 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Judging Criteria\";\n      t15 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Correctness (50%): Successfully matching all visible and hidden test cases.</li> <li>Efficiency (30%): Performance regarding time and space complexity, and the elegance of the algorithmic approach.</li> <li>Time to Solution (20%): Faster correct submissions will rank higher, with this score decreasing as the session progresses.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t13, anchor);\n      insert(target, h31, anchor);\n      insert(target, t15, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ul0);\n        detach(t13);\n        detach(h31);\n        detach(t15);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: {\n      name: \"Alphin Issac\",\n      phone: \"89219 74858\"\n    }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Aaditya Dinesh\",\n      phone: \"96453 99933\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let p;\n  let t3;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"For any queries, contact the event coordinators:\";\n      t3 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n        detach(t3);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP25_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_11(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"Petrichor 2026 proudly presents Linefollower, an exhilarating maze-solving competition. Teams must build an autonomous robot that can follow white lines and keep track of directions while navigating a complex maze. The robot must complete a dry run to reach the end point and then execute the shortest path in the actual run in the fastest time possible.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_10(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Robot Specs\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Scoring & Format\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#specs\",\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#scoring\",\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let h10;\n  let t1;\n  let centersection;\n  let t2;\n  let h11;\n  let t4;\n  let p0;\n  let t8;\n  let p1;\n  let t13;\n  let p2;\n  let t16;\n  let p3;\n  let t20;\n  let p4;\n  let t24;\n  let p5;\n  let t28;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_11] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h10 = element(\"h1\");\n      h10.textContent = \"Line Follower\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h11 = element(\"h1\");\n      h11.textContent = \"Event Details\";\n      t4 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Date:</strong> <strong>17th  of January, 2:00PM - 4:00PM</strong>`;\n      t8 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Resgistraion Fee:</strong> <strong>Rs 99</strong> per Head`;\n      t13 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Mode</strong>: Offline`;\n      t16 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Theme:</strong> <strong>Techno-cultural fest of IIT Palakkad</strong>`;\n      t20 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Team Size:</strong> <strong>1-4 members</strong>`;\n      t24 = space();\n      p5 = element(\"p\");\n      p5.innerHTML = `<strong>Prize Worth:</strong> <strong>\\u20B915,000</strong>`;\n      t28 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h10, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h11, anchor);\n      insert(target, t4, anchor);\n      insert(target, p0, anchor);\n      insert(target, t8, anchor);\n      insert(target, p1, anchor);\n      insert(target, t13, anchor);\n      insert(target, p2, anchor);\n      insert(target, t16, anchor);\n      insert(target, p3, anchor);\n      insert(target, t20, anchor);\n      insert(target, p4, anchor);\n      insert(target, t24, anchor);\n      insert(target, p5, anchor);\n      insert(target, t28, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h10);\n        detach(t1);\n        detach(t2);\n        detach(h11);\n        detach(t4);\n        detach(p0);\n        detach(t8);\n        detach(p1);\n        detach(t13);\n        detach(p2);\n        detach(t16);\n        detach(p3);\n        detach(t20);\n        detach(p4);\n        detach(t24);\n        detach(p5);\n        detach(t28);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h30;\n  let t1;\n  let ul0;\n  let t19;\n  let h31;\n  let t21;\n  let ul1;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Robot Specifications\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>The autonomous bot must fit into a box of dimension 22 cm x 22 cm x 22 cm (l x b x h).</li> <li>Robot must be started by only one switch; however, a team may have an onboard switch for restart.</li> <li>Robot must have an LED which will glow once it reaches the end zone of the arena.</li> <li>During the run, the autonomous bot must not damage the arena in any way.</li> <li>Robot must have an \\u2018onboard\\u2019 power supply.</li> <li>When using the electric power supply, the potential difference between any two points must not exceed 24 V at any point in time during the game.</li> <li>The autonomous robot should not separate or split into two or more units.</li> <li>The Robot cannot be constructed using ready-made \\u2018Lego kits\\u2019 or any ready-made mechanism.</li> <li>The team can use ready-made gear assemblies.</li>`;\n      t19 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Course Design\";\n      t21 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>The arena is composed of random paths made up of white lines on a dark background.</li> <li>There will be a maximum of 5 checkpoints in the arena.</li> <li>The angle between two intersection white lines in the path is 90\\xB0.</li> <li>The width of all white lines will be 3 cm.</li> <li>A white box of 30 cm x 30 cm is present at the end zone of the arena to indicate the END point.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t19, anchor);\n      insert(target, h31, anchor);\n      insert(target, t21, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ul0);\n        detach(t19);\n        detach(h31);\n        detach(t21);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h30;\n  let t1;\n  let ul0;\n  let t16;\n  let h31;\n  let t18;\n  let ul1;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Racing Format & Scoring\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li><strong>Checkpoints:</strong> 25 points will be given on crossing any of the checkpoints (counted once per checkpoint).</li> <li><strong>Run Points:</strong> 30 points for completing the Dry Run and 30 points for the Shortest Path in Actual Run.</li> <li><strong>Dry Run Score:</strong> 180 - (Total time taken in Dry Run).</li> <li><strong>Actual Run Score:</strong> 150 - (Total time taken in Actual Run).</li> <li><strong>LED Bonus:</strong> 10 points will be given for the LED to glow at the end of the Actual Run.</li>`;\n      t16 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Penalties\";\n      t18 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li><strong>Collision:</strong> 2-second penalty per collision with maze walls or obstacles.</li> <li><strong>Stalling:</strong> 5-second penalty if stationary for more than 10 seconds.</li> <li><strong>Manual Intervention:</strong> 10-second penalty for any manual reset.</li> <li><strong>Overtime:</strong> 10-second penalty for every additional 20 seconds.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t16, anchor);\n      insert(target, h31, anchor);\n      insert(target, t18, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ul0);\n        detach(t16);\n        detach(h31);\n        detach(t18);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h30;\n  let t1;\n  let ul;\n  let t11;\n  let h31;\n  let t13;\n  let p;\n  let t15;\n  let ol;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"General Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>One team member is allowed to handle the robot.</li> <li>Laptops/personal computers and Wi-Fi/Bluetooth devices must be switched off near the arena.</li> <li>The time measured by the organizers will be final and binding.</li> <li>Only one team is allowed inside the arena during their run.</li> <li>No team is allowed to take photographs or record their run.</li>`;\n      t11 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Judging & Tie-breaking\";\n      t13 = space();\n      p = element(\"p\");\n      p.textContent = \"Teams with the highest scores will be ranked 1st, 2nd, and 3rd. Tie-breaking criteria:\";\n      t15 = space();\n      ol = element(\"ol\");\n      ol.innerHTML = `<li>Shortest path traveled.</li> <li>Dry run completion status.</li> <li>Lowest Actual Run time, then lowest Dry Run time.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n      insert(target, t11, anchor);\n      insert(target, h31, anchor);\n      insert(target, t13, anchor);\n      insert(target, p, anchor);\n      insert(target, t15, anchor);\n      insert(target, ol, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ul);\n        detach(t11);\n        detach(h31);\n        detach(t13);\n        detach(p);\n        detach(t15);\n        detach(ol);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>First Prize:</strong> \\u20B97,500</li> <li><strong>Second Prize:</strong> \\u20B95,000</li> <li><strong>Third Prize:</strong> \\u20B92,500</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Srinivas B\", phone: \"8247412104\" }\n  });\n  person1 = new Person_default({\n    props: { name: \"Saketh\", phone: \"9391104718\" }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let p;\n  let t3;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"For any queries, contact the Organizers:\";\n      t3 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n        detach(t3);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let section3;\n  let t4;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"specs\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"scoring\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section3 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(section3.$$.fragment);\n      t4 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(section3, target, anchor);\n      insert(target, t4, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const section3_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section3_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section3.$set(section3_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(section3.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(section3.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n        detach(t4);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(section3, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP31_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t7;\n  let p2;\n  let t12;\n  let p3;\n  let t15;\n  let p4;\n  let t18;\n  let p5;\n  let t22;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Riptide\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"Riptide is a water-based robotics challenge where participants design and operate remote-controlled (RC) boats. This competition introduces technical dimensions such as fluid dynamics, buoyancy, and propulsion challenges.\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Date:</strong> <strong>18th  of January, 3:00PM - 5:00PM</strong>`;\n      t7 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Resgistraion Fee:</strong> <strong>Rs 99</strong> per Head`;\n      t12 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Team Size:</strong> 1-4 members`;\n      t15 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Mode</strong>: Offline`;\n      t18 = space();\n      p5 = element(\"p\");\n      p5.innerHTML = `<strong>Prizes Worth:</strong> <strong>\\u20B915,000 Total</strong>`;\n      t22 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t7, anchor);\n      insert(target, p2, anchor);\n      insert(target, t12, anchor);\n      insert(target, p3, anchor);\n      insert(target, t15, anchor);\n      insert(target, p4, anchor);\n      insert(target, t18, anchor);\n      insert(target, p5, anchor);\n      insert(target, t22, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t7);\n        detach(p2);\n        detach(t12);\n        detach(p3);\n        detach(t15);\n        detach(p4);\n        detach(t18);\n        detach(p5);\n        detach(t22);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Technical Specifications\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Dimensions: Max Length: 50 cm; Max Width: 30 cm.</li> <li>Weight: Maximum weight of 3 kg.</li> <li>Propulsion: Electric motors, propellers, or jet propulsion allowed.</li> <li>Power: Max voltage of 12V; sealed Li-ion or Li-Po batteries only.</li> <li>Control: Only RC operation permitted; autonomous systems are prohibited.</li> <li>Prohibited: Combustion engines or hazardous high-power components.</li> <li>Waterproofing: Electronics must be properly sealed, and hulls must be leakage-free.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let p0;\n  let t4;\n  let ul0;\n  let t10;\n  let p1;\n  let t12;\n  let ul1;\n  let t18;\n  let p2;\n  let t20;\n  let ul2;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"The Challenge\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Merged Obstacle Race:</strong>\nA single high-intensity stage combining:`;\n      t4 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Speed &amp; Navigation: Maneuvering through narrow channels.</li> <li>Technical Obstacles: Buoy zig-zags and rotating or floating obstacles.</li> <li>Final Sprint: Speed-based sprint across the final leg of the course.</li>`;\n      t10 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Scoring (60 Points Total):</strong>`;\n      t12 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Time &amp; Speed: 40 points.</li> <li>Clean Navigation: 10 points (Avoiding hits to obstacles).</li> <li>Maneuverability: 10 points (Smooth turns).</li>`;\n      t18 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Penalties:</strong>`;\n      t20 = space();\n      ul2 = element(\"ul\");\n      ul2.innerHTML = `<li>Collisions: -2 points per hit.</li> <li>Course Deviation: -5 points.</li> <li>Unauthorized Maintenance: -5 points for changing batteries mid-round without approval.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t4, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t10, anchor);\n      insert(target, p1, anchor);\n      insert(target, t12, anchor);\n      insert(target, ul1, anchor);\n      insert(target, t18, anchor);\n      insert(target, p2, anchor);\n      insert(target, t20, anchor);\n      insert(target, ul2, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p0);\n        detach(t4);\n        detach(ul0);\n        detach(t10);\n        detach(p1);\n        detach(t12);\n        detach(ul1);\n        detach(t18);\n        detach(p2);\n        detach(t20);\n        detach(ul2);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"General Regulations\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>All boats must undergo a safety inspection before the event.</li> <li>Teams may only use one boat and cannot replace motors during a round.</li> <li>In case of a tie, the fastest overall time decides the winner.</li> <li>Water pollution (oil/chemicals) results in immediate disqualification.</li> <li>Unsafe behavior or arena damage leads to heavy penalties or disqualification.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: {\n      name: \"Rakesh Kumar\",\n      phone: \"8003759174\"\n    }\n  });\n  person1 = new Person_default({\n    props: { name: \"Isha\", phone: \"70655 50491\" }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizers\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"regulations\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP21_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_9(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t7;\n  let p2;\n  let t12;\n  let p3;\n  let t15;\n  let p4;\n  let t18;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"CodeOps\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"CodeOps is an advanced algorithmic coding challenge designed to test participants\\u2019 problem-solving ability, algorithmic thinking, and efficiency under strict time constraints. Participants solve a set of problems that emphasize correctness, scalability, and disciplined coding practices.\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Date:</strong> <strong>17th  of January, 7:30PM - 10:30PM</strong>`;\n      t7 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Resgistraion Fee:</strong> <strong>Rs 99</strong> per Head`;\n      t12 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Mode</strong>: Online`;\n      t15 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Prizes Worth : </strong>Rs 15,000`;\n      t18 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t7, anchor);\n      insert(target, p2, anchor);\n      insert(target, t12, anchor);\n      insert(target, p3, anchor);\n      insert(target, t15, anchor);\n      insert(target, p4, anchor);\n      insert(target, t18, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t7);\n        detach(p2);\n        detach(t12);\n        detach(p3);\n        detach(t15);\n        detach(p4);\n        detach(t18);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Eligibility and Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participation is for individuals only.</li> <li>The contest is conducted offline at the CS Lab, IIT Palakkad.</li> <li>Allowed Languages: C++, C, Python, Java, and JavaScript.</li> <li>Internet access is not allowed, except for official documentation if explicitly permitted.</li> <li>External collaboration, communication, or assistance is strictly prohibited.</li> <li>No pre-written code or external libraries beyond standard ones are allowed.</li> <li>Any form of plagiarism or unfair means will result in immediate disqualification.</li> <li>The organizers&#39; decisions are final and binding.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let p0;\n  let t3;\n  let ul0;\n  let t11;\n  let p1;\n  let t13;\n  let ul1;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Event Structure\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Format:</strong>`;\n      t3 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Duration: 3 Hours.</li> <li>The contest consists of 5 questions of varying difficulty, all revealed at the start.</li> <li>Problems test algorithmic correctness, efficiency under large constraints, and edge-case handling.</li> <li>Some problems may include subtasks with increasing constraints for partial scoring.</li>`;\n      t11 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Submission Requirements:</strong>`;\n      t13 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Only source code files must be submitted.</li> <li>Output must strictly adhere to the specified format.</li> <li>Submissions must run successfully on the provided judge environment without external dependencies.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t11, anchor);\n      insert(target, p1, anchor);\n      insert(target, t13, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(ul0);\n        detach(t11);\n        detach(p1);\n        detach(t13);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Judging Criteria\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Correctness forms the primary basis of evaluation through automated judging.</li> <li>Time and space efficiency are enforced through large constraints and strict limits.</li> <li>Code quality and algorithmic efficiency may be manually evaluated for up to 20% of the total score.</li> <li>Tie-Breaking: Rankings are decided by total score, then fully solved problems, followed by penalty time (5 mins per wrong submission), and finally submission time.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>First Place: Prize worth 7000</li> <li>Second Place: Prize worth 5000</li> <li>Third Place: Prize worth 3000</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: {\n      name: \"Chaitanya Gupta\",\n      phone: \"6377536756\"\n    }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Nikhil Karlapudi\",\n      phone: \"7892664547\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizers\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let section3;\n  let t4;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"judging\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section3 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(section3.$$.fragment);\n      t4 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(section3, target, anchor);\n      insert(target, t4, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const section3_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section3_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section3.$set(section3_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(section3.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(section3.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n        detach(t4);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(section3, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CF22_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_8(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"Showcasing your talent, coordination, and creativity.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rules & Rounds\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let centersection;\n  let t2;\n  let h2;\n  let t4;\n  let p0;\n  let t8;\n  let p1;\n  let t12;\n  let p2;\n  let t15;\n  let p3;\n  let t19;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Step Sync Surge\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h2 = element(\"h2\");\n      h2.textContent = \"Event Details\";\n      t4 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Registration Fee:</strong> <strong>Rs. 179</strong>`;\n      t8 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Prizes:</strong> Worth <strong>20k</strong>`;\n      t12 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Team Size:</strong> 3 - 15 members`;\n      t15 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Submission Link for Round 1:</strong> <a href=\"https://docs.google.com/forms/d/e/1FAIpQLSdhjCmZJ0WUZbkN6ZScGvOqf8vCo55x0ZnSuooXOkHQliHJYA/viewform\" target=\"_blank\">Click Here</a>`;\n      t19 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h2, anchor);\n      insert(target, t4, anchor);\n      insert(target, p0, anchor);\n      insert(target, t8, anchor);\n      insert(target, p1, anchor);\n      insert(target, t12, anchor);\n      insert(target, p2, anchor);\n      insert(target, t15, anchor);\n      insert(target, p3, anchor);\n      insert(target, t19, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(t2);\n        detach(h2);\n        detach(t4);\n        detach(p0);\n        detach(t8);\n        detach(p1);\n        detach(t12);\n        detach(p2);\n        detach(t15);\n        detach(p3);\n        detach(t19);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h30;\n  let t1;\n  let ul0;\n  let t13;\n  let h31;\n  let t15;\n  let ul1;\n  let t41;\n  let h32;\n  let t43;\n  let ul2;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Round 1 (Online)\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Participants will have to shoot a video of them dancing in any style. Duration of the video must be between 1 to 3 minutes only.</li> <li>The video must have clear sound and visuals and must contain a recording of a live performance. All the members of the team should be clearly visible in the uploaded video.</li> <li>Upload your videos in your google drive in .mp4 format and submit the link of the same through the google form which will be provided via your registered email id.</li> <li>Only one submission per team is allowed.</li> <li>The deadline for submission of videos for the online screening round is on January 2024.</li> <li>The maximum number of participants is \\u2026 and will be selected on first - serve basis.</li>`;\n      t13 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Round 2 (Offline)\";\n      t15 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>The top entries will be shortlisted for the final round.</li> <li>The participant should be present in the venue at least 20 minutes before the scheduled commencement of the event.</li> <li>Violations of the rules may lead to disqualification.</li> <li>Team Composition: Teams should consist of a minimum of 3 and a maximum of 15 participants.</li> <li>Eligibility: Open to participants of all age groups and backgrounds.</li> <li>Performance Duration: Each team is allocated a total of 15 minutes, which includes time for stage setup and clearing. Performances exceeding this limit will incur penalties.</li> <li>Song Submission: All performance tracks must be submitted through the designated form by the provided deadline.</li> <li>Attire and Conduct: Participants must wear appropriate costumes and avoid offensive gestures or song selections.</li> <li>Props and Safety: Teams are responsible for their own props and costumes. Hazardous materials such as fire, sharp objects, or any items posing safety risks are prohibited.</li> <li>Timing: Teams should report to the venue 20 minutes before the event starts and must be backstage at least 5 minutes before their scheduled slot.</li> <li>Communication: Any last-minute changes or specific requirements must be conveyed to the event coordinators promptly.</li> <li>Respect and Integrity: All participants must exhibit sportsmanship and respect towards other teams, organizers, and judges throughout the competition.</li> <li>Final Decisions: The judges\\u2019 decisions are conclusive and cannot be challenged.</li>`;\n      t41 = space();\n      h32 = element(\"h3\");\n      h32.textContent = \"Performance Rules\";\n      t43 = space();\n      ul2 = element(\"ul\");\n      ul2.innerHTML = `<li>Dance Styles: All dance forms are welcome.</li> <li>Time Management: Performances must adhere to the allocated 15-minute slot.</li> <li>Maintain venue decorum and cooperate with event staff for a smooth experience.</li> <li>Teams failing to comply with the rules may face disqualification.</li> <li>Spotlights can be provided if requested, but please let us know in advance through the registration link.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t13, anchor);\n      insert(target, h31, anchor);\n      insert(target, t15, anchor);\n      insert(target, ul1, anchor);\n      insert(target, t41, anchor);\n      insert(target, h32, anchor);\n      insert(target, t43, anchor);\n      insert(target, ul2, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ul0);\n        detach(t13);\n        detach(h31);\n        detach(t15);\n        detach(ul1);\n        detach(t41);\n        detach(h32);\n        detach(t43);\n        detach(ul2);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Judging Criteria\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Choreography and Creativity: 30 points</li> <li>Synchronization and Expressions: 25 points</li> <li>Energy and Stage Presence: 25 points</li> <li>Costume and Appearance: 20 points</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Siddhardh\", phone: \"9145335333\" }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Bavanamrutha\",\n      phone: \"9985049999\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"judging\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CF21_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_9(ctx) {\n  let p0;\n  let t1;\n  let p1;\n  return {\n    c() {\n      p0 = element(\"p\");\n      p0.textContent = \"One spotlight. One beat. Infinite stories to tell. Dance is the hidden language of the soul, and tonight, we turn up the volume. We invite you to step out of the shadows and paint the stage with your movement. Whether it\\u2019s graceful fluidity or explosive power, let your body speak what words cannot. Come witness the magic as artistry meets adrenaline.\";\n      t1 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>No Duo (can take help for dialogues) - Open for all</strong>`;\n    },\n    m(target, anchor) {\n      insert(target, p0, anchor);\n      insert(target, t1, anchor);\n      insert(target, p1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p0);\n        detach(t1);\n        detach(p1);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rules & Rounds\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h1;\n  let t1;\n  let centersection;\n  let t2;\n  let h3;\n  let t4;\n  let p0;\n  let t10;\n  let p1;\n  let t13;\n  let p2;\n  let t17;\n  let p3;\n  let t21;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Solo Streak\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h3 = element(\"h3\");\n      h3.textContent = \"Event Details\";\n      t4 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Registration Period (Round 1):</strong> <strong>January 4th</strong> - <strong>January 10th</strong>`;\n      t10 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Registration Fee:</strong> Rs. 149`;\n      t13 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Prizes:</strong> Rs. <strong>6k</strong>`;\n      t17 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Submission Link for Round 1:</strong> <a href=\"https://docs.google.com/forms/d/e/1FAIpQLSepV6EiPhCcgIPP_sv9_l-2lKgte6n0a1_7YZQ06LkaSx0U1w/viewform\" target=\"_blank\">Click here</a>`;\n      t21 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h3, anchor);\n      insert(target, t4, anchor);\n      insert(target, p0, anchor);\n      insert(target, t10, anchor);\n      insert(target, p1, anchor);\n      insert(target, t13, anchor);\n      insert(target, p2, anchor);\n      insert(target, t17, anchor);\n      insert(target, p3, anchor);\n      insert(target, t21, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(t2);\n        detach(h3);\n        detach(t4);\n        detach(p0);\n        detach(t10);\n        detach(p1);\n        detach(t13);\n        detach(p2);\n        detach(t17);\n        detach(p3);\n        detach(t21);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Round 1 (Online)\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants will have to shoot a video of them dancing in any style. The duration of the video must be 1 minutes to 3 minutes only.</li> <li>The video must have clear sound and visuals which contains a recording of a live performance with a clear face in one take.</li> <li>Upload your videos in your google drive in .mp4 format and submit the link of the same through the google form which will be provided via your registered email id.</li> <li>Only one submission per participant is allowed.</li> <li>The deadline for online video submissions for Round 1 is from January 4th to January 10th. The participants chosen are based on first come first serve basis. So, make sure to submit your entries within this timeframe to qualify!</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Round 2 (Offline)\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Any dance style is allowed.</li> <li>The participants should avoid using indecent dress, song and gestures.</li> <li>Any stunts that can cause life risk are not permitted.</li> <li>Use of fire, sharp objects, or any other dangerous elements on stage is strictly prohibited.</li> <li>It is mandatory for all participants to be present at the venue before the competition begins.</li> <li>Any last-minute changes or requests should be communicated to the event coordinators well in advance.</li> <li>The judges\\u2019 decisions will be final and cannot be disputed.</li> <li>All participants are expected to display good sportsmanship and respect towards fellow participants, organizers, and judges.</li> <li>Spotlights will be provided upon request; however, the request must be communicated in advance through the registration links.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Judging Criteria\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Choreography and Creativity - 30%</li> <li>Synchronization and Expressions - 20%</li> <li>Energy and Stage Presence - 20%</li> <li>Costume and Appearance - 10%</li> <li>Overall Entertainment Value - 20%</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: {\n      name: \"Bavanamrutha\",\n      phone: \"9985049999\"\n    }\n  });\n  person1 = new Person_default({\n    props: { name: \"Siddhardh\", phone: \"9145335333\" }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rounds\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"judging\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CP23_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_9(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"Anything. Everything. And then some. The Petrichor General Quiz is here to test the limits of your knowledge.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rules & Format\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h10;\n  let t1;\n  let centersection;\n  let t2;\n  let h11;\n  let t4;\n  let p0;\n  let t7;\n  let p1;\n  let t11;\n  let p2;\n  let t16;\n  let p3;\n  let t18;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h10 = element(\"h1\");\n      h10.textContent = \"General Quiz\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      h11 = element(\"h1\");\n      h11.textContent = \"Event Details\";\n      t4 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Registration Fee:</strong> Rs. 49`;\n      t7 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Prizes:</strong> Worth <strong>2.5k</strong>`;\n      t11 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Team Size:</strong> Upto <strong>3</strong> members per team`;\n      t16 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Event open for: College students</strong>`;\n      t18 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h10, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, h11, anchor);\n      insert(target, t4, anchor);\n      insert(target, p0, anchor);\n      insert(target, t7, anchor);\n      insert(target, p1, anchor);\n      insert(target, t11, anchor);\n      insert(target, p2, anchor);\n      insert(target, t16, anchor);\n      insert(target, p3, anchor);\n      insert(target, t18, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h10);\n        detach(t1);\n        detach(t2);\n        detach(h11);\n        detach(t4);\n        detach(p0);\n        detach(t7);\n        detach(p1);\n        detach(t11);\n        detach(p2);\n        detach(t16);\n        detach(p3);\n        detach(t18);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Teams would contain at most three participants.</li> <li>Teams should arrive at least 30 mins before the start of the event for verification.</li> <li>The prelims round will be held with 20 questions in written format.</li> <li>Papers will be provided. It is advised to bring your own pens.</li> <li>Engaging in any kind of malpractice will lead to disqualification.</li> <li>The decision taken by the quizmasters will be final and binding.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Format\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>The quiz consists of two rounds: prelims and finals.</li> <li>The top 8 individuals from the preliminary round will qualify for the finals.</li> <li>Finals will be on-stage.</li> <li>The general bounce and pounce system will be followed for finals (will be further explained on-spot).</li> <li>Round-specific rules will be explained on the spot.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool Distribution\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>1st Place:</strong> \\u20B91500</li> <li><strong>2nd Place:</strong> \\u20B91000</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person;\n  let current;\n  person = new Person_default({\n    props: { name: \"Adinath\", phone: \"7902220690\" }\n  });\n  return {\n    c() {\n      create_component(person.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(person, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"format\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CF34_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let h3;\n  let t3;\n  let p0;\n  let t5;\n  let h2;\n  let t7;\n  let p1;\n  let t10;\n  let p2;\n  let t13;\n  let p3;\n  let t16;\n  let p4;\n  let t20;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Voicestra\";\n      t1 = space();\n      h3 = element(\"h3\");\n      h3.textContent = \"Solo-Singing competition\";\n      t3 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"A captivating solo singing competition where one voice takes center stage, showcasing emotion, skill, and stage presence. Let your voice shine and leave the audience spellbound!\";\n      t5 = space();\n      h2 = element(\"h2\");\n      h2.textContent = \"Event Details\";\n      t7 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Registration Fee:</strong> Rs. 149`;\n      t10 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Prizes Worth:</strong> 6k`;\n      t13 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Competition type:</strong> Solo`;\n      t16 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Submission Link for Round 1:</strong> <a href=\"https://docs.google.com/forms/d/e/1FAIpQLSecEkxMHXkZk8NmB9YQYtigNVHMHVWGuauh1z3DyzoZiSupMg/viewform?usp=header\" target=\"_blank\">Click Here</a>`;\n      t20 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, h3, anchor);\n      insert(target, t3, anchor);\n      insert(target, p0, anchor);\n      insert(target, t5, anchor);\n      insert(target, h2, anchor);\n      insert(target, t7, anchor);\n      insert(target, p1, anchor);\n      insert(target, t10, anchor);\n      insert(target, p2, anchor);\n      insert(target, t13, anchor);\n      insert(target, p3, anchor);\n      insert(target, t16, anchor);\n      insert(target, p4, anchor);\n      insert(target, t20, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(h3);\n        detach(t3);\n        detach(p0);\n        detach(t5);\n        detach(h2);\n        detach(t7);\n        detach(p1);\n        detach(t10);\n        detach(p2);\n        detach(t13);\n        detach(p3);\n        detach(t16);\n        detach(p4);\n        detach(t20);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants can sing songs in any genre.</li> <li>Participants may perform with Karaoke tracks (must be provided in advance, preferably in MP3 format).</li> <li>Participants may perform with live instruments; participants must arrange their own instruments and accompanists (maximum of one accompanist).</li> <li>No pre-recorded vocals or backing tracks with lead vocals are allowed.</li> <li>Sound checks will be arranged before the event starts.</li> <li>Participants must ensure their tracks or instruments are tested during the sound check.</li> <li>Obscenity on stage is strictly prohibited.</li> <li>Exceeding the time limit will lead to negative points.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let p0;\n  let t4;\n  let ul0;\n  let t12;\n  let p1;\n  let t15;\n  let ul1;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Structure\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Round 1 (Online Submissions):</strong> Participants perform a song of their choice and upload a video of it in the drive link provided.`;\n      t4 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>The participant should be clearly visible in the uploaded video.</li> <li>The uploaded video should be under the time limit of 3 minutes.</li> <li>Audio in the uploaded file should be clear for the judges to evaluate.</li> <li>Editing software (Audacity, Reaper, etc.) can be used.</li>`;\n      t12 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Round 2 (Finale Round):</strong> Selected entries will perform live on stage in Petrichor.`;\n      t15 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Time limit: maximum of 7 minutes (including setup and soundchecks).</li> <li>The participant performing offline must be the same as in the uploaded video.</li> <li>Judges&#39; decisions are final and binding.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t4, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t12, anchor);\n      insert(target, p1, anchor);\n      insert(target, t15, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p0);\n        detach(t4);\n        detach(ul0);\n        detach(t12);\n        detach(p1);\n        detach(t15);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Yazeed\", phone: \"8593930099\" }\n  });\n  person1 = new Person_default({\n    props: { name: \"Prachurjya\", phone: \"9435301264\" }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizers\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP38_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t7;\n  let p2;\n  let t10;\n  let p3;\n  let t15;\n  let p4;\n  let t18;\n  let p5;\n  let t22;\n  let p6;\n  let t26;\n  let p7;\n  let t30;\n  let p8;\n  let t34;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"CAD vs CAD\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"Put your 3D modeling speed and precision to the test in this head-to-head challenge. Competitors must replicate a given CAD drawing within a strict time limit, focusing on exact dimensions and material accuracy.\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Date:</strong> <strong>18th  of January, 10:45AM- 12:30PM</strong>`;\n      t7 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Software Allowed:</strong> SolidWorks, Autodesk Fusion360, Catia`;\n      t10 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Resgistraion Fee:</strong> <strong>Rs 99</strong> per Head`;\n      t15 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Mode</strong>: Online &amp; Offline`;\n      t18 = space();\n      p5 = element(\"p\");\n      p5.innerHTML = `<strong>Prizes Worth:</strong> <strong>\\u20B910,000 Total</strong>`;\n      t22 = space();\n      p6 = element(\"p\");\n      p6.innerHTML = `<strong>1st:</strong> <strong>\\u20B9 5000</strong>`;\n      t26 = space();\n      p7 = element(\"p\");\n      p7.innerHTML = `<strong>2nd:</strong> <strong>\\u20B9 3000</strong>`;\n      t30 = space();\n      p8 = element(\"p\");\n      p8.innerHTML = `<strong>3rd:</strong> <strong>\\u20B9 2000</strong>`;\n      t34 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t7, anchor);\n      insert(target, p2, anchor);\n      insert(target, t10, anchor);\n      insert(target, p3, anchor);\n      insert(target, t15, anchor);\n      insert(target, p4, anchor);\n      insert(target, t18, anchor);\n      insert(target, p5, anchor);\n      insert(target, t22, anchor);\n      insert(target, p6, anchor);\n      insert(target, t26, anchor);\n      insert(target, p7, anchor);\n      insert(target, t30, anchor);\n      insert(target, p8, anchor);\n      insert(target, t34, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t7);\n        detach(p2);\n        detach(t10);\n        detach(p3);\n        detach(t15);\n        detach(p4);\n        detach(t18);\n        detach(p5);\n        detach(t22);\n        detach(p6);\n        detach(t26);\n        detach(p7);\n        detach(t30);\n        detach(p8);\n        detach(t34);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"General Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>No use of AI is allowed for any task.</li> <li>Time for each model will be disclosed based on the complexity of the model.</li> <li>All models should have cast carbon steel (7800 kg/m3) as material.</li> <li>CAD drawing will be displayed for each model to be made.</li> <li>No hidden geometries or dummy extrusions are allowed; the model must be precise to the drawing.</li> <li>Malpractices, including looking at opponents&#39; screens or using internet resources, lead to disqualification.</li> <li>Judges\\u2019 decision will be final and no queries on the decision would be entertained.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let p;\n  let t3;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Competition Procedure\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"For a set of competitors, a CAD drawing will be presented. Participants are given a specific time to create the model.\";\n      t3 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Models are judged primarily based on weight.</li> <li>If weights are tied, time and dimensions will be used as the tie-breaker.</li> <li>If neither participant finishes in the given time, an extra 5 minutes will be provided for the pair.</li> <li>The weight of the model will not be disclosed to participants.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p);\n        detach(t3);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Material Specifications (Cast Carbon Steel)\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Mass Density: 7800 kg/m3</li> <li>Elastic Modulus: 200000 N/mm2</li> <li>Poisson&#39;s Ratio: 0.32</li> <li>Shear Modulus: 76000 N/mm2</li> <li>Tensile Strength: 482.549 N/mm2</li> <li>Yield Strength: 248.168 N/mm2</li> <li>Thermal Conductivity: 30 W/(m\\xB7K)</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person;\n  let current;\n  person = new Person_default({\n    props: {\n      name: \"Vibhanshu Hire\",\n      phone: \"7666465043\"\n    }\n  });\n  return {\n    c() {\n      create_component(person.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(person, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizers\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"specs\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP32_2026": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-umbtni\", '.main.svelte-umbtni{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-umbtni{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-umbtni{font-family:var(--pfont) !important;overflow:hidden;width:100% !important;text-overflow:clip;word-wrap:break-word;font-weight:700}p.svelte-umbtni{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;overflow:hidden;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-umbtni\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-umbtni\");\n      attr(p, \"class\", \"svelte-umbtni\");\n      attr(div1, \"class\", \"main svelte-umbtni\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.webp`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-jp8458\", \"div.svelte-jp8458{display:flex;flex-direction:column;align-items:center;margin:10px;text-align:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-jp8458\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-146aj7j\", \".buttons.svelte-146aj7j{margin-top:2rem;margin-bottom:2rem}button.svelte-146aj7j{border:none;background-color:transparent}.a-unset.svelte-146aj7j{text-decoration:none;color:white}.register.svelte-146aj7j{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-146aj7j:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-146aj7j{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-146aj7j{margin:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-146aj7j\");\n      attr(div, \"class\", \"buttons svelte-146aj7j\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_9(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"A high-energy competition centered on learning, creativity, and community. Whether you are a seasoned developer or a complete beginner, this jam is the perfect place to experiment with new engines, languages, or genres. Build something unique, adhere to the theme, and share your creation with the world.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Eligibility\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rules & Assets\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register Now\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#eligibility\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let centersection;\n  let t2;\n  let p0;\n  let t7;\n  let p1;\n  let t11;\n  let p2;\n  let t14;\n  let p3;\n  let t17;\n  let p4;\n  let t20;\n  let p5;\n  let t23;\n  let p6;\n  let t26;\n  let p7;\n  let t29;\n  let p8;\n  let t32;\n  let p9;\n  let t35;\n  let flexsection;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"INDIE SPARK\";\n      t1 = space();\n      create_component(centersection.$$.fragment);\n      t2 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Registration Fee:</strong> <strong>Rs 99</strong> per Head`;\n      t7 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `<strong>Date:</strong> <strong>16th-18th of January</strong>`;\n      t11 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `<strong>Mode</strong>: Online`;\n      t14 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `<strong>Participation:</strong> Solo or Team-based`;\n      t17 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `<strong>Platform:</strong> itch.io`;\n      t20 = space();\n      p5 = element(\"p\");\n      p5.innerHTML = `<strong>Prizes Worth:</strong> Rs 10000`;\n      t23 = space();\n      p6 = element(\"p\");\n      p6.innerHTML = `<strong>1st :</strong> Rs 5000`;\n      t26 = space();\n      p7 = element(\"p\");\n      p7.innerHTML = `<strong>2nd :</strong> Rs 3000`;\n      t29 = space();\n      p8 = element(\"p\");\n      p8.innerHTML = `<strong>3rd :</strong> Rs 2000`;\n      t32 = space();\n      p9 = element(\"p\");\n      p9.innerHTML = `<strong>Team Size:</strong> No strict limit (Small teams recommended)`;\n      t35 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t2, anchor);\n      insert(target, p0, anchor);\n      insert(target, t7, anchor);\n      insert(target, p1, anchor);\n      insert(target, t11, anchor);\n      insert(target, p2, anchor);\n      insert(target, t14, anchor);\n      insert(target, p3, anchor);\n      insert(target, t17, anchor);\n      insert(target, p4, anchor);\n      insert(target, t20, anchor);\n      insert(target, p5, anchor);\n      insert(target, t23, anchor);\n      insert(target, p6, anchor);\n      insert(target, t26, anchor);\n      insert(target, p7, anchor);\n      insert(target, t29, anchor);\n      insert(target, p8, anchor);\n      insert(target, t32, anchor);\n      insert(target, p9, anchor);\n      insert(target, t35, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(t2);\n        detach(p0);\n        detach(t7);\n        detach(p1);\n        detach(t11);\n        detach(p2);\n        detach(t14);\n        detach(p3);\n        detach(t17);\n        detach(p4);\n        detach(t20);\n        detach(p5);\n        detach(t23);\n        detach(p6);\n        detach(t26);\n        detach(p7);\n        detach(t29);\n        detach(p8);\n        detach(t32);\n        detach(p9);\n        detach(t35);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Eligibility\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Anyone can join, regardless of whether you are a first-time developer or an experienced jam veteran.</li> <li>Beginners are especially welcome to discover that game development is accessible with the right resources.</li> <li>Experienced developers are encouraged to learn something new, such as a different engine, language, or genre.</li> <li>Participants may work alone or in teams.</li> <li>There is no strict limit to team size, though smaller teams are recommended for better communication.</li> <li>You may join multiple teams, but participating in more than two is not recommended.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h30;\n  let t1;\n  let ul0;\n  let t13;\n  let h31;\n  let t15;\n  let ul1;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Asset and Crediting Rules\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>All external resources must be credited in the game credits or on the itch.io page by stating the resource type, creator&#39;s name, and a link.</li> <li>Using uncredited resources will lead to immediate disqualification.</li> <li>You may use pre-existing code and libraries that you have the rights to use, including your own previous work.</li> <li>All assets specific to the game must be created within the jam timeframe.</li> <li>AI Prohibition: You may not use AI for art, writing, audio, or code, including for ideation.</li> <li>We recommend following tutorials, using public domain assets, or collaborating with teammates instead of using AI.</li>`;\n      t13 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Submission & Judging\";\n      t15 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Only one team member is required to submit the game on itch.io; teammates can be added as Admins under the project settings.</li> <li>Judging is based on theme adherence, aesthetics, mechanics, and overall creativity.</li> <li>The most critical factor for evaluation is how well the game incorporates the announced theme.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t13, anchor);\n      insert(target, h31, anchor);\n      insert(target, t15, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ul0);\n        detach(t13);\n        detach(h31);\n        detach(t15);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Yazeed\", phone: \"8593930099\" }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Reehan Joseph Mathews\",\n      phone: \"9845003949\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let p;\n  let t3;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Contact Us\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"For any queries regarding the Game Jam, contact the organizers:\";\n      t3 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n        detach(t3);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      url: backgroundImageUrl,\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"eligibility\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar backgroundImageUrl = \"https://cdn.midjourney.com/a9735b80-ad6b-4b1f-a8f9-0621f262cd31/0_1.webp\";\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  }
}